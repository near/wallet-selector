"use strict";(self.webpackChunkangular=self.webpackChunkangular||[]).push([[8344],{78344:(An,se,st)=>{st.r(se),st.d(se,{encodeToCurve:()=>Sn,hashToCurve:()=>xn,schnorr:()=>pn,secp256k1:()=>St});var Vt={};st.r(Vt),st.d(Vt,{Fy:()=>tt,uw:()=>ut,gk:()=>W,Dd:()=>le,dQ:()=>jt,ci:()=>lt,bytesToNumberBE:()=>Q,ty:()=>zt,eV:()=>j,n$:()=>he,ql:()=>V,hexToBytes:()=>ht,Z2:()=>gt,_t:()=>ct,H9:()=>Yt,tL:()=>F,S5:()=>Mt,uz:()=>dt,iY:()=>Rt,FF:()=>wt});var qt=st(32622),pt=st(40512),Nt=st(93284);class ce extends pt.kb{constructor(n,e){super(),this.finished=!1,this.destroyed=!1,(0,Nt.z3)(n);const r=(0,pt.O0)(e);if(this.iHash=n.create(),"function"!=typeof this.iHash.update)throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const o=this.blockLen,i=new Uint8Array(o);i.set(r.length>o?n.create().update(r).digest():r);for(let c=0;c<i.length;c++)i[c]^=54;this.iHash.update(i),this.oHash=n.create();for(let c=0;c<i.length;c++)i[c]^=106;this.oHash.update(i),i.fill(0)}update(n){return(0,Nt.$h)(this),this.iHash.update(n),this}digestInto(n){(0,Nt.$h)(this),(0,Nt.gk)(n,this.outputLen),this.finished=!0,this.iHash.digestInto(n),this.oHash.update(n),this.oHash.digestInto(n),this.destroy()}digest(){const n=new Uint8Array(this.oHash.outputLen);return this.digestInto(n),n}_cloneInto(n){n||(n=Object.create(Object.getPrototypeOf(this),{}));const{oHash:e,iHash:r,finished:o,destroyed:i,blockLen:c,outputLen:f}=this;return n.finished=o,n.destroyed=i,n.blockLen=c,n.outputLen=f,n.oHash=e._cloneInto(n.oHash),n.iHash=r._cloneInto(n.iHash),n}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const fe=(t,n,e)=>new ce(t,n).update(e).digest();fe.create=(t,n)=>new ce(t,n);const Tt=BigInt(0),_t=BigInt(1),He=BigInt(2);function ct(t){return t instanceof Uint8Array||ArrayBuffer.isView(t)&&"Uint8Array"===t.constructor.name}function W(t){if(!ct(t))throw new Error("Uint8Array expected")}function ut(t,n){if("boolean"!=typeof n)throw new Error(t+" boolean expected, got "+n)}const Ze=Array.from({length:256},(t,n)=>n.toString(16).padStart(2,"0"));function lt(t){W(t);let n="";for(let e=0;e<t.length;e++)n+=Ze[t[e]];return n}function dt(t){const n=t.toString(16);return 1&n.length?"0"+n:n}function ae(t){if("string"!=typeof t)throw new Error("hex string expected, got "+typeof t);return""===t?Tt:BigInt("0x"+t)}const X={_0:48,_9:57,A:65,F:70,a:97,f:102};function ue(t){return t>=X._0&&t<=X._9?t-X._0:t>=X.A&&t<=X.F?t-(X.A-10):t>=X.a&&t<=X.f?t-(X.a-10):void 0}function ht(t){if("string"!=typeof t)throw new Error("hex string expected, got "+typeof t);const n=t.length,e=n/2;if(n%2)throw new Error("hex string expected, got unpadded hex of length "+n);const r=new Uint8Array(e);for(let o=0,i=0;o<e;o++,i+=2){const c=ue(t.charCodeAt(i)),f=ue(t.charCodeAt(i+1));if(void 0===c||void 0===f){const s=t[i]+t[i+1];throw new Error('hex string expected, got non-hex character "'+s+'" at index '+i)}r[o]=16*c+f}return r}function Q(t){return ae(lt(t))}function zt(t){return W(t),ae(lt(Uint8Array.from(t).reverse()))}function F(t,n){return ht(t.toString(16).padStart(2*n,"0"))}function Mt(t,n){return F(t,n).reverse()}function V(t,n,e){let r;if("string"==typeof n)try{r=ht(n)}catch(i){throw new Error(t+" must be hex string or Uint8Array, cause: "+i)}else{if(!ct(n))throw new Error(t+" must be hex string or Uint8Array");r=Uint8Array.from(n)}const o=r.length;if("number"==typeof e&&o!==e)throw new Error(t+" of length "+e+" expected, got "+o);return r}function j(...t){let n=0;for(let r=0;r<t.length;r++){const o=t[r];W(o),n+=o.length}const e=new Uint8Array(n);for(let r=0,o=0;r<t.length;r++){const i=t[r];e.set(i,o),o+=i.length}return e}function Rt(t){if("string"!=typeof t)throw new Error("string expected");return new Uint8Array((new TextEncoder).encode(t))}const Pt=t=>"bigint"==typeof t&&Tt<=t;function gt(t,n,e){return Pt(t)&&Pt(n)&&Pt(e)&&n<=t&&t<e}function tt(t,n,e,r){if(!gt(n,e,r))throw new Error("expected valid "+t+": "+e+" <= n < "+r+", got "+n)}function le(t){let n;for(n=0;t>Tt;t>>=_t,n+=1);return n}const jt=t=>(He<<BigInt(t-1))-_t,Kt=t=>new Uint8Array(t),de=t=>Uint8Array.from(t);function he(t,n,e){if("number"!=typeof t||t<2)throw new Error("hashLen must be a number");if("number"!=typeof n||n<2)throw new Error("qByteLen must be a number");if("function"!=typeof e)throw new Error("hmacFn must be a function");let r=Kt(t),o=Kt(t),i=0;const c=()=>{r.fill(1),o.fill(0),i=0},f=(...w)=>e(o,r,...w),s=(w=Kt())=>{o=f(de([0]),w),r=f(),0!==w.length&&(o=f(de([1]),w),r=f())},u=()=>{if(i++>=1e3)throw new Error("drbg: tried 1000 values");let w=0;const l=[];for(;w<n;){r=f();const g=r.slice();l.push(g),w+=r.length}return j(...l)};return(w,l)=>{let g;for(c(),s(w);!(g=l(u()));)s();return c(),g}}const Ve={bigint:t=>"bigint"==typeof t,function:t=>"function"==typeof t,boolean:t=>"boolean"==typeof t,string:t=>"string"==typeof t,stringOrUint8Array:t=>"string"==typeof t||ct(t),isSafeInteger:t=>Number.isSafeInteger(t),array:t=>Array.isArray(t),field:(t,n)=>n.Fp.isValid(t),hash:t=>"function"==typeof t&&Number.isSafeInteger(t.outputLen)};function wt(t,n,e={}){const r=(o,i,c)=>{const f=Ve[i];if("function"!=typeof f)throw new Error("invalid validator function");const s=t[o];if(!(c&&void 0===s||f(s,t)))throw new Error("param "+String(o)+" is invalid. Expected "+i+", got "+s)};for(const[o,i]of Object.entries(n))r(o,i,!1);for(const[o,i]of Object.entries(e))r(o,i,!0);return t}function Yt(t){const n=new WeakMap;return(e,...r)=>{const o=n.get(e);if(void 0!==o)return o;const i=t(e,...r);return n.set(e,i),i}}const H=BigInt(0),L=BigInt(1),et=BigInt(2),ze=BigInt(3),Dt=BigInt(4),ge=BigInt(5),we=BigInt(8);function U(t,n){const e=t%n;return e>=H?e:n+e}function je(t,n,e){if(n<H)throw new Error("invalid exponent, negatives unsupported");if(e<=H)throw new Error("invalid modulus");if(e===L)return H;let r=L;for(;n>H;)n&L&&(r=r*t%e),t=t*t%e,n>>=L;return r}function Y(t,n,e){let r=t;for(;n-- >H;)r*=r,r%=e;return r}function Lt(t,n){if(t===H)throw new Error("invert: expected non-zero number");if(n<=H)throw new Error("invert: expected positive modulus, got "+n);let e=U(t,n),r=n,o=H,i=L,c=L,f=H;for(;e!==H;){const u=r/e,d=r%e,w=o-c*u,l=i-f*u;r=e,e=d,o=c,i=f,c=w,f=l}if(r!==L)throw new Error("invert: does not exist");return U(o,n)}function Ye(t){if(t%Dt===ze){const n=(t+L)/Dt;return function(r,o){const i=r.pow(o,n);if(!r.eql(r.sqr(i),o))throw new Error("Cannot find square root");return i}}if(t%we===ge){const n=(t-ge)/we;return function(r,o){const i=r.mul(o,et),c=r.pow(i,n),f=r.mul(o,c),s=r.mul(r.mul(f,et),c),u=r.mul(f,r.sub(s,r.ONE));if(!r.eql(r.sqr(u),o))throw new Error("Cannot find square root");return u}}return function Ke(t){const n=(t-L)/et;let e,r,o;for(e=t-L,r=0;e%et===H;e/=et,r++);for(o=et;o<t&&je(o,n,t)!==t-L;o++)if(o>1e3)throw new Error("Cannot find square root: likely non-prime P");if(1===r){const c=(t+L)/Dt;return function(s,u){const d=s.pow(u,c);if(!s.eql(s.sqr(d),u))throw new Error("Cannot find square root");return d}}const i=(e+L)/et;return function(f,s){if(f.pow(s,n)===f.neg(f.ONE))throw new Error("Cannot find square root");let u=r,d=f.pow(f.mul(f.ONE,o),e),w=f.pow(s,i),l=f.pow(s,e);for(;!f.eql(l,f.ONE);){if(f.eql(l,f.ZERO))return f.ZERO;let g=1;for(let b=f.sqr(l);g<u&&!f.eql(b,f.ONE);g++)b=f.sqr(b);const S=f.pow(d,L<<BigInt(u-g-1));d=f.sqr(S),w=f.mul(w,S),l=f.mul(l,d),u=g}return w}}(t)}const De=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function me(t){return wt(t,De.reduce((r,o)=>(r[o]="function",r),{ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"}))}function Gt(t,n){const e=void 0!==n?n:t.toString(2).length;return{nBitLength:e,nByteLength:Math.ceil(e/8)}}function ye(t,n,e=!1,r={}){if(t<=H)throw new Error("invalid field: expected ORDER > 0, got "+t);const{nBitLength:o,nByteLength:i}=Gt(t,n);if(i>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let c;const f=Object.freeze({ORDER:t,isLE:e,BITS:o,BYTES:i,MASK:jt(o),ZERO:H,ONE:L,create:s=>U(s,t),isValid:s=>{if("bigint"!=typeof s)throw new Error("invalid field element: expected bigint, got "+typeof s);return H<=s&&s<t},is0:s=>s===H,isOdd:s=>(s&L)===L,neg:s=>U(-s,t),eql:(s,u)=>s===u,sqr:s=>U(s*s,t),add:(s,u)=>U(s+u,t),sub:(s,u)=>U(s-u,t),mul:(s,u)=>U(s*u,t),pow:(s,u)=>function Ge(t,n,e){if(e<H)throw new Error("invalid exponent, negatives unsupported");if(e===H)return t.ONE;if(e===L)return n;let r=t.ONE,o=n;for(;e>H;)e&L&&(r=t.mul(r,o)),o=t.sqr(o),e>>=L;return r}(f,s,u),div:(s,u)=>U(s*Lt(u,t),t),sqrN:s=>s*s,addN:(s,u)=>s+u,subN:(s,u)=>s-u,mulN:(s,u)=>s*u,inv:s=>Lt(s,t),sqrt:r.sqrt||(s=>(c||(c=Ye(t)),c(f,s))),invertBatch:s=>function We(t,n){const e=new Array(n.length),r=n.reduce((i,c,f)=>t.is0(c)?i:(e[f]=i,t.mul(i,c)),t.ONE),o=t.inv(r);return n.reduceRight((i,c,f)=>t.is0(c)?i:(e[f]=t.mul(i,e[f]),t.mul(i,c)),o),e}(f,s),cmov:(s,u,d)=>d?u:s,toBytes:s=>e?Mt(s,i):F(s,i),fromBytes:s=>{if(s.length!==i)throw new Error("Field.fromBytes: expected "+i+" bytes, got "+s.length);return e?zt(s):Q(s)}});return Object.freeze(f)}function be(t){if("bigint"!=typeof t)throw new Error("field order must be bigint");const n=t.toString(2).length;return Math.ceil(n/8)}function Ee(t){const n=be(t);return n+Math.ceil(n/2)}const pe=BigInt(0),kt=BigInt(1);function Wt(t,n){const e=n.negate();return t?e:n}function Qt(t,n){if(!Number.isSafeInteger(t)||t<=0||t>n)throw new Error("invalid window size, expected [1.."+n+"], got W="+t)}function Xt(t,n){Qt(t,n);return{windows:Math.ceil(n/t)+1,windowSize:2**(t-1)}}function ve(t,n){if(!Array.isArray(t))throw new Error("array expected");t.forEach((e,r)=>{if(!(e instanceof n))throw new Error("invalid point at index "+r)})}function Be(t,n){if(!Array.isArray(t))throw new Error("array of scalars expected");t.forEach((e,r)=>{if(!n.isValid(e))throw new Error("invalid scalar at index "+r)})}const Jt=new WeakMap,xe=new WeakMap;function $t(t){return xe.get(t)||1}function Se(t){return me(t.Fp),wt(t,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...Gt(t.n,t.nBitLength),...t,p:t.Fp.ORDER})}function Ae(t){void 0!==t.lowS&&ut("lowS",t.lowS),void 0!==t.prehash&&ut("prehash",t.prehash)}const{bytesToNumberBE:tn,hexToBytes:en}=Vt;class nn extends Error{constructor(n=""){super(n)}}const J={Err:nn,_tlv:{encode:(t,n)=>{const{Err:e}=J;if(t<0||t>256)throw new e("tlv.encode: wrong tag");if(1&n.length)throw new e("tlv.encode: unpadded data");const r=n.length/2,o=dt(r);if(o.length/2&128)throw new e("tlv.encode: long form length too big");const i=r>127?dt(o.length/2|128):"";return dt(t)+i+o+n},decode(t,n){const{Err:e}=J;let r=0;if(t<0||t>256)throw new e("tlv.encode: wrong tag");if(n.length<2||n[r++]!==t)throw new e("tlv.decode: wrong tlv");const o=n[r++];let c=0;if(!!(128&o)){const s=127&o;if(!s)throw new e("tlv.decode(long): indefinite length not supported");if(s>4)throw new e("tlv.decode(long): byte length is too big");const u=n.subarray(r,r+s);if(u.length!==s)throw new e("tlv.decode: length bytes not complete");if(0===u[0])throw new e("tlv.decode(long): zero leftmost byte");for(const d of u)c=c<<8|d;if(r+=s,c<128)throw new e("tlv.decode(long): not minimal encoding")}else c=o;const f=n.subarray(r,r+c);if(f.length!==c)throw new e("tlv.decode: wrong value length");return{v:f,l:n.subarray(r+c)}}},_int:{encode(t){const{Err:n}=J;if(t<D)throw new n("integer: negative integers are not allowed");let e=dt(t);if(8&Number.parseInt(e[0],16)&&(e="00"+e),1&e.length)throw new n("unexpected DER parsing assertion: unpadded hex");return e},decode(t){const{Err:n}=J;if(128&t[0])throw new n("invalid signature integer: negative");if(0===t[0]&&!(128&t[1]))throw new n("invalid signature integer: unnecessary leading zero");return tn(t)}},toSig(t){const{Err:n,_int:e,_tlv:r}=J,o="string"==typeof t?en(t):t;W(o);const{v:i,l:c}=r.decode(48,o);if(c.length)throw new n("invalid signature: left bytes after parsing");const{v:f,l:s}=r.decode(2,i),{v:u,l:d}=r.decode(2,s);if(d.length)throw new n("invalid signature: left bytes after parsing");return{r:e.decode(f),s:e.decode(u)}},hexFromSig(t){const{_tlv:n,_int:e}=J,i=n.encode(2,e.encode(t.r))+n.encode(2,e.encode(t.s));return n.encode(48,i)}},D=BigInt(0),_=BigInt(1),nt=BigInt(2),Ut=BigInt(3),Ie=BigInt(4);function rn(t){const n=function Fe(t){const n=Se(t);wt(n,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:e,Fp:r,a:o}=n;if(e){if(!r.eql(o,r.ZERO))throw new Error("invalid endomorphism, can only be defined for Koblitz curves that have a=0");if("object"!=typeof e||"bigint"!=typeof e.beta||"function"!=typeof e.splitScalar)throw new Error("invalid endomorphism, expected beta: bigint and splitScalar: function")}return Object.freeze({...n})}(t),{Fp:e}=n,r=ye(n.n,n.nBitLength),o=n.toBytes||((b,a,h)=>{const m=a.toAffine();return j(Uint8Array.from([4]),e.toBytes(m.x),e.toBytes(m.y))}),i=n.fromBytes||(b=>{const a=b.subarray(1);return{x:e.fromBytes(a.subarray(0,e.BYTES)),y:e.fromBytes(a.subarray(e.BYTES,2*e.BYTES))}});function c(b){const{a,b:h}=n,m=e.sqr(b),E=e.mul(m,b);return e.add(e.add(E,e.mul(b,a)),h)}if(!e.eql(e.sqr(n.Gy),c(n.Gx)))throw new Error("bad generator point: equation left != right");function s(b){const{allowedPrivateKeyLengths:a,nByteLength:h,wrapPrivateKey:m,n:E}=n;if(a&&"bigint"!=typeof b){if(ct(b)&&(b=lt(b)),"string"!=typeof b||!a.includes(b.length))throw new Error("invalid private key");b=b.padStart(2*h,"0")}let B;try{B="bigint"==typeof b?b:Q(V("private key",b,h))}catch{throw new Error("invalid private key, expected hex or "+h+" bytes, got "+typeof b)}return m&&(B=U(B,E)),tt("private key",B,_,E),B}function u(b){if(!(b instanceof l))throw new Error("ProjectivePoint expected")}const d=Yt((b,a)=>{const{px:h,py:m,pz:E}=b;if(e.eql(E,e.ONE))return{x:h,y:m};const B=b.is0();null==a&&(a=B?e.ONE:e.inv(E));const N=e.mul(h,a),O=e.mul(m,a),x=e.mul(E,a);if(B)return{x:e.ZERO,y:e.ZERO};if(!e.eql(x,e.ONE))throw new Error("invZ was invalid");return{x:N,y:O}}),w=Yt(b=>{if(b.is0()){if(n.allowInfinityPoint&&!e.is0(b.py))return;throw new Error("bad point: ZERO")}const{x:a,y:h}=b.toAffine();if(!e.isValid(a)||!e.isValid(h))throw new Error("bad point: x or y not FE");const m=e.sqr(h),E=c(a);if(!e.eql(m,E))throw new Error("bad point: equation left != right");if(!b.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});class l{constructor(a,h,m){if(this.px=a,this.py=h,this.pz=m,null==a||!e.isValid(a))throw new Error("x required");if(null==h||!e.isValid(h))throw new Error("y required");if(null==m||!e.isValid(m))throw new Error("z required");Object.freeze(this)}static fromAffine(a){const{x:h,y:m}=a||{};if(!a||!e.isValid(h)||!e.isValid(m))throw new Error("invalid affine point");if(a instanceof l)throw new Error("projective point not allowed");const E=B=>e.eql(B,e.ZERO);return E(h)&&E(m)?l.ZERO:new l(h,m,e.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(a){const h=e.invertBatch(a.map(m=>m.pz));return a.map((m,E)=>m.toAffine(h[E])).map(l.fromAffine)}static fromHex(a){const h=l.fromAffine(i(V("pointHex",a)));return h.assertValidity(),h}static fromPrivateKey(a){return l.BASE.multiply(s(a))}static msm(a,h){return function $e(t,n,e,r){if(ve(e,t),Be(r,n),e.length!==r.length)throw new Error("arrays of points and scalars must have equal length");const o=t.ZERO,i=le(BigInt(e.length)),c=i>12?i-3:i>4?i-2:i?2:1,f=(1<<c)-1,s=new Array(f+1).fill(o);let d=o;for(let w=Math.floor((n.BITS-1)/c)*c;w>=0;w-=c){s.fill(o);for(let g=0;g<r.length;g++){const S=r[g],b=Number(S>>BigInt(w)&BigInt(f));s[b]=s[b].add(e[g])}let l=o;for(let g=s.length-1,S=o;g>0;g--)S=S.add(s[g]),l=l.add(S);if(d=d.add(l),0!==w)for(let g=0;g<c;g++)d=d.double()}return d}(l,r,a,h)}_setWindowSize(a){S.setWindowSize(this,a)}assertValidity(){w(this)}hasEvenY(){const{y:a}=this.toAffine();if(e.isOdd)return!e.isOdd(a);throw new Error("Field doesn't support isOdd")}equals(a){u(a);const{px:h,py:m,pz:E}=this,{px:B,py:N,pz:O}=a,x=e.eql(e.mul(h,O),e.mul(B,E)),I=e.eql(e.mul(m,O),e.mul(N,E));return x&&I}negate(){return new l(this.px,e.neg(this.py),this.pz)}double(){const{a,b:h}=n,m=e.mul(h,Ut),{px:E,py:B,pz:N}=this;let O=e.ZERO,x=e.ZERO,I=e.ZERO,A=e.mul(E,E),Z=e.mul(B,B),k=e.mul(N,N),R=e.mul(E,B);return R=e.add(R,R),I=e.mul(E,N),I=e.add(I,I),O=e.mul(a,I),x=e.mul(m,k),x=e.add(O,x),O=e.sub(Z,x),x=e.add(Z,x),x=e.mul(O,x),O=e.mul(R,O),I=e.mul(m,I),k=e.mul(a,k),R=e.sub(A,k),R=e.mul(a,R),R=e.add(R,I),I=e.add(A,A),A=e.add(I,A),A=e.add(A,k),A=e.mul(A,R),x=e.add(x,A),k=e.mul(B,N),k=e.add(k,k),A=e.mul(k,R),O=e.sub(O,A),I=e.mul(k,Z),I=e.add(I,I),I=e.add(I,I),new l(O,x,I)}add(a){u(a);const{px:h,py:m,pz:E}=this,{px:B,py:N,pz:O}=a;let x=e.ZERO,I=e.ZERO,A=e.ZERO;const Z=n.a,k=e.mul(n.b,Ut);let R=e.mul(h,B),K=e.mul(m,N),y=e.mul(E,O),p=e.add(h,m),v=e.add(B,N);p=e.mul(p,v),v=e.add(R,K),p=e.sub(p,v),v=e.add(h,E);let q=e.add(B,O);return v=e.mul(v,q),q=e.add(R,y),v=e.sub(v,q),q=e.add(m,E),x=e.add(N,O),q=e.mul(q,x),x=e.add(K,y),q=e.sub(q,x),A=e.mul(Z,v),x=e.mul(k,y),A=e.add(x,A),x=e.sub(K,A),A=e.add(K,A),I=e.mul(x,A),K=e.add(R,R),K=e.add(K,R),y=e.mul(Z,y),v=e.mul(k,v),K=e.add(K,y),y=e.sub(R,y),y=e.mul(Z,y),v=e.add(v,y),R=e.mul(K,v),I=e.add(I,R),R=e.mul(q,v),x=e.mul(p,x),x=e.sub(x,R),R=e.mul(p,K),A=e.mul(q,A),A=e.add(A,R),new l(x,I,A)}subtract(a){return this.add(a.negate())}is0(){return this.equals(l.ZERO)}wNAF(a){return S.wNAFCached(this,a,l.normalizeZ)}multiplyUnsafe(a){const{endo:h,n:m}=n;tt("scalar",a,D,m);const E=l.ZERO;if(a===D)return E;if(this.is0()||a===_)return this;if(!h||S.hasPrecomputes(this))return S.wNAFCachedUnsafe(this,a,l.normalizeZ);let{k1neg:B,k1:N,k2neg:O,k2:x}=h.splitScalar(a),I=E,A=E,Z=this;for(;N>D||x>D;)N&_&&(I=I.add(Z)),x&_&&(A=A.add(Z)),Z=Z.double(),N>>=_,x>>=_;return B&&(I=I.negate()),O&&(A=A.negate()),A=new l(e.mul(A.px,h.beta),A.py,A.pz),I.add(A)}multiply(a){const{endo:h,n:m}=n;let E,B;if(tt("scalar",a,_,m),h){const{k1neg:N,k1:O,k2neg:x,k2:I}=h.splitScalar(a);let{p:A,f:Z}=this.wNAF(O),{p:k,f:R}=this.wNAF(I);A=S.constTimeNegate(N,A),k=S.constTimeNegate(x,k),k=new l(e.mul(k.px,h.beta),k.py,k.pz),E=A.add(k),B=Z.add(R)}else{const{p:N,f:O}=this.wNAF(a);E=N,B=O}return l.normalizeZ([E,B])[0]}multiplyAndAddUnsafe(a,h,m){const E=l.BASE,B=(O,x)=>x!==D&&x!==_&&O.equals(E)?O.multiply(x):O.multiplyUnsafe(x),N=B(this,h).add(B(a,m));return N.is0()?void 0:N}toAffine(a){return d(this,a)}isTorsionFree(){const{h:a,isTorsionFree:h}=n;if(a===_)return!0;if(h)return h(l,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:a,clearCofactor:h}=n;return a===_?this:h?h(l,this):this.multiplyUnsafe(n.h)}toRawBytes(a=!0){return ut("isCompressed",a),this.assertValidity(),o(l,this,a)}toHex(a=!0){return ut("isCompressed",a),lt(this.toRawBytes(a))}}l.BASE=new l(n.Gx,n.Gy,e.ONE),l.ZERO=new l(e.ZERO,e.ONE,e.ZERO);const g=n.nBitLength,S=function Je(t,n){return{constTimeNegate:Wt,hasPrecomputes:e=>1!==$t(e),unsafeLadder(e,r,o=t.ZERO){let i=e;for(;r>pe;)r&kt&&(o=o.add(i)),i=i.double(),r>>=kt;return o},precomputeWindow(e,r){const{windows:o,windowSize:i}=Xt(r,n),c=[];let f=e,s=f;for(let u=0;u<o;u++){s=f,c.push(s);for(let d=1;d<i;d++)s=s.add(f),c.push(s);f=s.double()}return c},wNAF(e,r,o){const{windows:i,windowSize:c}=Xt(e,n);let f=t.ZERO,s=t.BASE;const u=BigInt(2**e-1),d=2**e,w=BigInt(e);for(let l=0;l<i;l++){const g=l*c;let S=Number(o&u);o>>=w,S>c&&(S-=d,o+=kt);const b=g,a=g+Math.abs(S)-1,h=l%2!=0,m=S<0;0===S?s=s.add(Wt(h,r[b])):f=f.add(Wt(m,r[a]))}return{p:f,f:s}},wNAFUnsafe(e,r,o,i=t.ZERO){const{windows:c,windowSize:f}=Xt(e,n),s=BigInt(2**e-1),u=2**e,d=BigInt(e);for(let w=0;w<c;w++){const l=w*f;if(o===pe)break;let g=Number(o&s);if(o>>=d,g>f&&(g-=u,o+=kt),0===g)continue;let S=r[l+Math.abs(g)-1];g<0&&(S=S.negate()),i=i.add(S)}return i},getPrecomputes(e,r,o){let i=Jt.get(r);return i||(i=this.precomputeWindow(r,e),1!==e&&Jt.set(r,o(i))),i},wNAFCached(e,r,o){const i=$t(e);return this.wNAF(i,this.getPrecomputes(i,e,o),r)},wNAFCachedUnsafe(e,r,o,i){const c=$t(e);return 1===c?this.unsafeLadder(e,r,i):this.wNAFUnsafe(c,this.getPrecomputes(c,e,o),r,i)},setWindowSize(e,r){Qt(r,n),xe.set(e,r),Jt.delete(e)}}}(l,n.endo?Math.ceil(g/2):g);return{CURVE:n,ProjectivePoint:l,normPrivateKeyToScalar:s,weierstrassEquation:c,isWithinCurveOrder:function f(b){return gt(b,_,n.n)}}}function sn(t){const n=function on(t){const n=Se(t);return wt(n,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...n})}(t),{Fp:e,n:r}=n,o=e.BYTES+1,i=2*e.BYTES+1;function c(y){return U(y,r)}function f(y){return Lt(y,r)}const{ProjectivePoint:s,normPrivateKeyToScalar:u,weierstrassEquation:d,isWithinCurveOrder:w}=rn({...n,toBytes(y,p,v){const q=p.toAffine(),T=e.toBytes(q.x),C=j;return ut("isCompressed",v),v?C(Uint8Array.from([p.hasEvenY()?2:3]),T):C(Uint8Array.from([4]),T,e.toBytes(q.y))},fromBytes(y){const p=y.length,v=y[0],q=y.subarray(1);if(p!==o||2!==v&&3!==v){if(p===i&&4===v){return{x:e.fromBytes(q.subarray(0,e.BYTES)),y:e.fromBytes(q.subarray(e.BYTES,2*e.BYTES))}}throw new Error("invalid Point, expected length of "+o+", or uncompressed "+i+", got "+p)}{const T=Q(q);if(!gt(T,_,e.ORDER))throw new Error("Point is not on curve");const C=d(T);let M;try{M=e.sqrt(C)}catch(G){const P=G instanceof Error?": "+G.message:"";throw new Error("Point is not on curve"+P)}return 1==(1&v)!==((M&_)===_)&&(M=e.neg(M)),{x:T,y:M}}}}),l=y=>lt(F(y,n.nByteLength));function g(y){return y>r>>_}const b=(y,p,v)=>Q(y.slice(p,v));class a{constructor(p,v,q){this.r=p,this.s=v,this.recovery=q,this.assertValidity()}static fromCompact(p){const v=n.nByteLength;return p=V("compactSignature",p,2*v),new a(b(p,0,v),b(p,v,2*v))}static fromDER(p){const{r:v,s:q}=J.toSig(V("DER",p));return new a(v,q)}assertValidity(){tt("r",this.r,_,r),tt("s",this.s,_,r)}addRecoveryBit(p){return new a(this.r,this.s,p)}recoverPublicKey(p){const{r:v,s:q,recovery:T}=this,C=O(V("msgHash",p));if(null==T||![0,1,2,3].includes(T))throw new Error("recovery id invalid");const M=2===T||3===T?v+n.n:v;if(M>=e.ORDER)throw new Error("recovery id 2 or 3 invalid");const z=1&T?"03":"02",$=s.fromHex(z+l(M)),G=f(M),P=c(-C*G),yt=c(q*G),it=s.BASE.multiplyAndAddUnsafe($,P,yt);if(!it)throw new Error("point at infinify");return it.assertValidity(),it}hasHighS(){return g(this.s)}normalizeS(){return this.hasHighS()?new a(this.r,c(-this.s),this.recovery):this}toDERRawBytes(){return ht(this.toDERHex())}toDERHex(){return J.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return ht(this.toCompactHex())}toCompactHex(){return l(this.r)+l(this.s)}}const h={isValidPrivateKey(y){try{return u(y),!0}catch{return!1}},normPrivateKeyToScalar:u,randomPrivateKey:()=>{const y=Ee(n.n);return function Xe(t,n,e=!1){const r=t.length,o=be(n),i=Ee(n);if(r<16||r<i||r>1024)throw new Error("expected "+i+"-1024 bytes of input, got "+r);const f=U(e?zt(t):Q(t),n-L)+L;return e?Mt(f,o):F(f,o)}(n.randomBytes(y),n.n)},precompute:(y=8,p=s.BASE)=>(p._setWindowSize(y),p.multiply(BigInt(3)),p)};function E(y){const p=ct(y),v="string"==typeof y,q=(p||v)&&y.length;return p?q===o||q===i:v?q===2*o||q===2*i:y instanceof s}const N=n.bits2int||function(y){if(y.length>8192)throw new Error("input is too large");const p=Q(y),v=8*y.length-n.nBitLength;return v>0?p>>BigInt(v):p},O=n.bits2int_modN||function(y){return c(N(y))},x=jt(n.nBitLength);function I(y){return tt("num < 2^"+n.nBitLength,y,D,x),F(y,n.nByteLength)}function A(y,p,v=Z){if(["recovered","canonical"].some(ft=>ft in v))throw new Error("sign() legacy options not supported");const{hash:q,randomBytes:T}=n;let{lowS:C,prehash:M,extraEntropy:z}=v;null==C&&(C=!0),y=V("msgHash",y),Ae(v),M&&(y=V("prehashed msgHash",q(y)));const $=O(y),G=u(p),P=[I(G),I($)];if(null!=z&&!1!==z){const ft=!0===z?T(e.BYTES):z;P.push(V("extraEntropy",ft))}const yt=j(...P),it=$;return{seed:yt,k2sig:function oe(ft){const bt=N(ft);if(!w(bt))return;const ie=f(bt),It=s.BASE.multiply(bt).toAffine(),at=c(It.x);if(at===D)return;const Ot=c(ie*c(it+at*G));if(Ot===D)return;let Et=(It.x===at?0:2)|Number(It.y&_),Ce=Ot;return C&&g(Ot)&&(Ce=function S(y){return g(y)?c(-y):y}(Ot),Et^=1),new a(at,Ce,Et)}}}const Z={lowS:n.lowS,prehash:!1},k={lowS:n.lowS,prehash:!1};return s.BASE._setWindowSize(8),{CURVE:n,getPublicKey:function m(y,p=!0){return s.fromPrivateKey(y).toRawBytes(p)},getSharedSecret:function B(y,p,v=!0){if(E(y))throw new Error("first arg must be private key");if(!E(p))throw new Error("second arg must be public key");return s.fromHex(p).multiply(u(y)).toRawBytes(v)},sign:function R(y,p,v=Z){const{seed:q,k2sig:T}=A(y,p,v),C=n;return he(C.hash.outputLen,C.nByteLength,C.hmac)(q,T)},verify:function K(y,p,v,q=k){const T=y;p=V("msgHash",p),v=V("publicKey",v);const{lowS:C,prehash:M,format:z}=q;if(Ae(q),"strict"in q)throw new Error("options.strict was renamed to lowS");if(void 0!==z&&"compact"!==z&&"der"!==z)throw new Error("format must be compact or der");const $="string"==typeof T||ct(T),G=!$&&!z&&"object"==typeof T&&null!==T&&"bigint"==typeof T.r&&"bigint"==typeof T.s;if(!$&&!G)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let P,yt;try{if(G&&(P=new a(T.r,T.s)),$){try{"compact"!==z&&(P=a.fromDER(T))}catch(Et){if(!(Et instanceof J.Err))throw Et}!P&&"der"!==z&&(P=a.fromCompact(T))}yt=s.fromHex(v)}catch{return!1}if(!P||C&&P.hasHighS())return!1;M&&(p=n.hash(p));const{r:it,s:oe}=P,ft=O(p),bt=f(oe),ie=c(ft*bt),It=c(it*bt),at=s.BASE.multiplyAndAddUnsafe(yt,ie,It)?.toAffine();return!!at&&c(at.x)===it},ProjectivePoint:s,Signature:a,utils:h}}function fn(t,n){if(me(t),!t.isValid(n.A)||!t.isValid(n.B)||!t.isValid(n.Z))throw new Error("mapToCurveSimpleSWU: invalid opts");const e=function cn(t,n){const e=t.ORDER;let r=D;for(let S=e-_;S%nt===D;S/=nt)r+=_;const o=r,i=nt<<o-_-_,c=i*nt,f=(e-_)/c,s=(f-_)/nt,u=c-_,d=i,w=t.pow(n,f),l=t.pow(n,(f+_)/nt);let g=(S,b)=>{let a=w,h=t.pow(b,u),m=t.sqr(h);m=t.mul(m,b);let E=t.mul(S,m);E=t.pow(E,s),E=t.mul(E,h),h=t.mul(E,b),m=t.mul(E,S);let B=t.mul(m,h);E=t.pow(B,d);let N=t.eql(E,t.ONE);h=t.mul(m,l),E=t.mul(B,a),m=t.cmov(h,m,N),B=t.cmov(E,B,N);for(let O=o;O>_;O--){let x=O-nt;x=nt<<x-_;let I=t.pow(B,x);const A=t.eql(I,t.ONE);h=t.mul(m,a),a=t.mul(a,a),I=t.mul(B,a),m=t.cmov(h,m,A),B=t.cmov(I,B,A)}return{isValid:N,value:m}};if(t.ORDER%Ie===Ut){const S=(t.ORDER-Ut)/Ie,b=t.sqrt(t.neg(n));g=(a,h)=>{let m=t.sqr(h);const E=t.mul(a,h);m=t.mul(m,E);let B=t.pow(m,S);B=t.mul(B,E);const N=t.mul(B,b),O=t.mul(t.sqr(B),h),x=t.eql(O,a);return{isValid:x,value:t.cmov(N,B,x)}}}return g}(t,n.Z);if(!t.isOdd)throw new Error("Fp.isOdd is not implemented!");return r=>{let o,i,c,f,s,u,d,w;o=t.sqr(r),o=t.mul(o,n.Z),i=t.sqr(o),i=t.add(i,o),c=t.add(i,t.ONE),c=t.mul(c,n.B),f=t.cmov(n.Z,t.neg(i),!t.eql(i,t.ZERO)),f=t.mul(f,n.A),i=t.sqr(c),u=t.sqr(f),s=t.mul(u,n.A),i=t.add(i,s),i=t.mul(i,c),u=t.mul(u,f),s=t.mul(u,n.B),i=t.add(i,s),d=t.mul(o,c);const{isValid:l,value:g}=e(i,u);w=t.mul(o,r),w=t.mul(w,g),d=t.cmov(d,c,l),w=t.cmov(w,g,l);const S=t.isOdd(r)===t.isOdd(w);return w=t.cmov(t.neg(w),w,S),d=t.div(d,f),{x:d,y:w}}}function an(t){return{hash:t,hmac:(n,...e)=>fe(t,n,(0,pt.eV)(...e)),randomBytes:pt.O6}}const ln=Q;function rt(t,n){if(vt(t),vt(n),t<0||t>=1<<8*n)throw new Error("invalid I2OSP input: "+t);const e=Array.from({length:n}).fill(0);for(let r=n-1;r>=0;r--)e[r]=255&t,t>>>=8;return new Uint8Array(e)}function dn(t,n){const e=new Uint8Array(t.length);for(let r=0;r<t.length;r++)e[r]=t[r]^n[r];return e}function vt(t){if(!Number.isSafeInteger(t))throw new Error("number expected")}function Oe(t,n,e){wt(e,{DST:"stringOrUint8Array",p:"bigint",m:"isSafeInteger",k:"isSafeInteger",hash:"hash"});const{p:r,k:o,m:i,hash:c,expand:f,DST:s}=e;W(t),vt(n);const u="string"==typeof s?Rt(s):s,d=r.toString(2).length,w=Math.ceil((d+o)/8),l=n*i*w;let g;if("xmd"===f)g=function hn(t,n,e,r){W(t),W(n),vt(e),n.length>255&&(n=r(j(Rt("H2C-OVERSIZE-DST-"),n)));const{outputLen:o,blockLen:i}=r,c=Math.ceil(e/o);if(e>65535||c>255)throw new Error("expand_message_xmd: invalid lenInBytes");const f=j(n,rt(n.length,1)),s=rt(0,i),u=rt(e,2),d=new Array(c),w=r(j(s,t,u,rt(0,1),f));d[0]=r(j(w,rt(1,1),f));for(let g=1;g<=c;g++){const S=[dn(w,d[g-1]),rt(g+1,1),f];d[g]=r(j(...S))}return j(...d).slice(0,e)}(t,u,l,c);else if("xof"===f)g=function gn(t,n,e,r,o){if(W(t),W(n),vt(e),n.length>255){const i=Math.ceil(2*r/8);n=o.create({dkLen:i}).update(Rt("H2C-OVERSIZE-DST-")).update(n).digest()}if(e>65535||n.length>255)throw new Error("expand_message_xof: invalid lenInBytes");return o.create({dkLen:e}).update(t).update(rt(e,2)).update(n).update(rt(n.length,1)).digest()}(t,u,l,o,c);else{if("_internal_pass"!==f)throw new Error('expand must be "xmd" or "xof"');g=t}const S=new Array(n);for(let b=0;b<n;b++){const a=new Array(i);for(let h=0;h<i;h++){const m=w*(h+b*i),E=g.subarray(m,m+w);a[h]=U(ln(E),r)}S[b]=a}return S}const Bt=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),Ct=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),xt=BigInt(1),Ht=BigInt(2),qe=(t,n)=>(t+n/Ht)/n;function Ne(t){const n=Bt,e=BigInt(3),r=BigInt(6),o=BigInt(11),i=BigInt(22),c=BigInt(23),f=BigInt(44),s=BigInt(88),u=t*t*t%n,d=u*u*t%n,w=Y(d,e,n)*d%n,l=Y(w,e,n)*d%n,g=Y(l,Ht,n)*u%n,S=Y(g,o,n)*g%n,b=Y(S,i,n)*S%n,a=Y(b,f,n)*b%n,h=Y(a,s,n)*a%n,m=Y(h,f,n)*b%n,E=Y(m,e,n)*d%n,B=Y(E,c,n)*S%n,N=Y(B,r,n)*u%n,O=Y(N,Ht,n);if(!ot.eql(ot.sqr(O),t))throw new Error("Cannot find square root");return O}const ot=ye(Bt,void 0,void 0,{sqrt:Ne}),St=function un(t,n){const e=r=>sn({...t,...an(r)});return{...e(n),create:e}}({a:BigInt(0),b:BigInt(7),Fp:ot,n:Ct,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:t=>{const n=Ct,e=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),r=-xt*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),o=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),i=e,c=BigInt("0x100000000000000000000000000000000"),f=qe(i*t,n),s=qe(-r*t,n);let u=U(t-f*e-s*o,n),d=U(-f*r-s*i,n);const w=u>c,l=d>c;if(w&&(u=n-u),l&&(d=n-d),u>c||d>c)throw new Error("splitScalar: Endomorphism failed, k="+t);return{k1neg:w,k1:u,k2neg:l,k2:d}}}},qt.JQ),Te=BigInt(0),_e={};function Zt(t,...n){let e=_e[t];if(void 0===e){const r=(0,qt.JQ)(Uint8Array.from(t,o=>o.charCodeAt(0)));e=j(r,r),_e[t]=e}return(0,qt.JQ)(j(e,...n))}const Ft=t=>t.toRawBytes(!0).slice(1),te=t=>F(t,32),ee=t=>U(t,Bt),At=t=>U(t,Ct),ne=St.ProjectivePoint,yn=(t,n,e)=>ne.BASE.multiplyAndAddUnsafe(t,n,e);function re(t){let n=St.utils.normPrivateKeyToScalar(t),e=ne.fromPrivateKey(n);return{scalar:e.hasEvenY()?n:At(-n),bytes:Ft(e)}}function Re(t){tt("x",t,xt,Bt);const n=ee(t*t);let r=Ne(ee(n*t+BigInt(7)));r%Ht!==Te&&(r=ee(-r));const o=new ne(t,r,xt);return o.assertValidity(),o}const mt=Q;function Le(...t){return At(mt(Zt("BIP0340/challenge",...t)))}function bn(t){return re(t).bytes}function En(t,n,e=(0,pt.O6)(32)){const r=V("message",t),{bytes:o,scalar:i}=re(n),c=V("auxRand",e,32),f=te(i^mt(Zt("BIP0340/aux",c))),s=Zt("BIP0340/nonce",f,o,r),u=At(mt(s));if(u===Te)throw new Error("sign failed: k is zero");const{bytes:d,scalar:w}=re(u),l=Le(d,o,r),g=new Uint8Array(64);if(g.set(d,0),g.set(te(At(w+l*i)),32),!ke(g,r,o))throw new Error("sign: Invalid signature produced");return g}function ke(t,n,e){const r=V("signature",t,64),o=V("message",n),i=V("publicKey",e,32);try{const c=Re(mt(i)),f=mt(r.subarray(0,32));if(!gt(f,xt,Bt))return!1;const s=mt(r.subarray(32,64));if(!gt(s,xt,Ct))return!1;const u=Le(te(f),Ft(c),o),d=yn(c,s,At(-u));return!(!d||!d.hasEvenY()||d.toAffine().x!==f)}catch{return!1}}const pn=(()=>({getPublicKey:bn,sign:En,verify:ke,utils:{randomPrivateKey:St.utils.randomPrivateKey,lift_x:Re,pointToBytes:Ft,numberToBytesBE:F,bytesToNumberBE:Q,taggedHash:Zt,mod:U}}))(),vn=(()=>function wn(t,n){const e=n.map(r=>Array.from(r).reverse());return(r,o)=>{const[i,c,f,s]=e.map(u=>u.reduce((d,w)=>t.add(t.mul(d,r),w)));return r=t.div(i,c),o=t.mul(o,t.div(f,s)),{x:r,y:o}}}(ot,[["0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7","0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581","0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262","0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"],["0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b","0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14","0x0000000000000000000000000000000000000000000000000000000000000001"],["0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c","0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3","0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931","0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"],["0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b","0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573","0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f","0x0000000000000000000000000000000000000000000000000000000000000001"]].map(t=>t.map(n=>BigInt(n)))))(),Bn=(()=>fn(ot,{A:BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),B:BigInt("1771"),Z:ot.create(BigInt("-11"))}))(),Ue=(()=>function mn(t,n,e){if("function"!=typeof n)throw new Error("mapToCurve() must be defined");return{hashToCurve(r,o){const i=Oe(r,2,{...e,DST:e.DST,...o}),c=t.fromAffine(n(i[0])),f=t.fromAffine(n(i[1])),s=c.add(f).clearCofactor();return s.assertValidity(),s},encodeToCurve(r,o){const i=Oe(r,1,{...e,DST:e.encodeDST,...o}),c=t.fromAffine(n(i[0])).clearCofactor();return c.assertValidity(),c},mapToCurve(r){if(!Array.isArray(r))throw new Error("mapToCurve: expected array of bigints");for(const i of r)if("bigint"!=typeof i)throw new Error("mapToCurve: expected array of bigints");const o=t.fromAffine(n(r)).clearCofactor();return o.assertValidity(),o}}}(St.ProjectivePoint,t=>{const{x:n,y:e}=Bn(ot.create(t[0]));return vn(n,e)},{DST:"secp256k1_XMD:SHA-256_SSWU_RO_",encodeDST:"secp256k1_XMD:SHA-256_SSWU_NU_",p:ot.ORDER,m:1,k:128,expand:"xmd",hash:qt.JQ}))(),xn=(()=>Ue.hashToCurve)(),Sn=(()=>Ue.encodeToCurve)()}}]);