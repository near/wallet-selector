"use strict";(self.webpackChunkangular=self.webpackChunkangular||[]).push([[8195],{88195:(le,At,Q)=>{Q.r(At),Q.d(At,{encodeToCurve:()=>de,hashToCurve:()=>fe,schnorr:()=>ie,secp256k1:()=>ct});var lt=Q(87501),rt=Q(40512),ut=Q(93284);class Ot extends rt.kb{constructor(e,t){super(),this.finished=!1,this.destroyed=!1,(0,ut.z3)(e);const o=(0,rt.O0)(t);if(this.iHash=e.create(),"function"!=typeof this.iHash.update)throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const a=this.blockLen,f=new Uint8Array(a);f.set(o.length>a?e.create().update(o).digest():o);for(let c=0;c<f.length;c++)f[c]^=54;this.iHash.update(f),this.oHash=e.create();for(let c=0;c<f.length;c++)f[c]^=106;this.oHash.update(f),f.fill(0)}update(e){return(0,ut.$h)(this),this.iHash.update(e),this}digestInto(e){(0,ut.$h)(this),(0,ut.gk)(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));const{oHash:t,iHash:o,finished:a,destroyed:f,blockLen:c,outputLen:p}=this;return e.finished=a,e.destroyed=f,e.blockLen=c,e.outputLen=p,e.oHash=t._cloneInto(e.oHash),e.iHash=o._cloneInto(e.iHash),e}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const Rt=(n,e,t)=>new Ot(n,e).update(t).digest();Rt.create=(n,e)=>new Ot(n,e);var ht=Q(98288),L=Q(94213),s=Q(1920);function qt(n){void 0!==n.lowS&&(0,s.uw)("lowS",n.lowS),void 0!==n.prehash&&(0,s.uw)("prehash",n.prehash)}const{bytesToNumberBE:zt,hexToBytes:Dt}=s;class Kt extends Error{constructor(e=""){super(e)}}const Y={Err:Kt,_tlv:{encode:(n,e)=>{const{Err:t}=Y;if(n<0||n>256)throw new t("tlv.encode: wrong tag");if(1&e.length)throw new t("tlv.encode: unpadded data");const o=e.length/2,a=s.uz(o);if(a.length/2&128)throw new t("tlv.encode: long form length too big");const f=o>127?s.uz(a.length/2|128):"";return s.uz(n)+f+a+e},decode(n,e){const{Err:t}=Y;let o=0;if(n<0||n>256)throw new t("tlv.encode: wrong tag");if(e.length<2||e[o++]!==n)throw new t("tlv.decode: wrong tlv");const a=e[o++];let c=0;if(!!(128&a)){const y=127&a;if(!y)throw new t("tlv.decode(long): indefinite length not supported");if(y>4)throw new t("tlv.decode(long): byte length is too big");const v=e.subarray(o,o+y);if(v.length!==y)throw new t("tlv.decode: length bytes not complete");if(0===v[0])throw new t("tlv.decode(long): zero leftmost byte");for(const B of v)c=c<<8|B;if(o+=y,c<128)throw new t("tlv.decode(long): not minimal encoding")}else c=a;const p=e.subarray(o,o+c);if(p.length!==c)throw new t("tlv.decode: wrong value length");return{v:p,l:e.subarray(o+c)}}},_int:{encode(n){const{Err:e}=Y;if(n<D)throw new e("integer: negative integers are not allowed");let t=s.uz(n);if(8&Number.parseInt(t[0],16)&&(t="00"+t),1&t.length)throw new e("unexpected DER parsing assertion: unpadded hex");return t},decode(n){const{Err:e}=Y;if(128&n[0])throw new e("invalid signature integer: negative");if(0===n[0]&&!(128&n[1]))throw new e("invalid signature integer: unnecessary leading zero");return zt(n)}},toSig(n){const{Err:e,_int:t,_tlv:o}=Y,a="string"==typeof n?Dt(n):n;s.gk(a);const{v:f,l:c}=o.decode(48,a);if(c.length)throw new e("invalid signature: left bytes after parsing");const{v:p,l:y}=o.decode(2,f),{v,l:B}=o.decode(2,y);if(B.length)throw new e("invalid signature: left bytes after parsing");return{r:t.decode(p),s:t.decode(v)}},hexFromSig(n){const{_tlv:e,_int:t}=Y,f=e.encode(2,t.encode(n.r))+e.encode(2,t.encode(n.s));return e.encode(48,f)}},D=BigInt(0),N=BigInt(1),M=BigInt(2),mt=BigInt(3),It=BigInt(4);function Yt(n){const e=function Ut(n){const e=(0,ht.Kd)(n);s.FF(e,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:t,Fp:o,a}=e;if(t){if(!o.eql(a,o.ZERO))throw new Error("invalid endomorphism, can only be defined for Koblitz curves that have a=0");if("object"!=typeof t||"bigint"!=typeof t.beta||"function"!=typeof t.splitScalar)throw new Error("invalid endomorphism, expected beta: bigint and splitScalar: function")}return Object.freeze({...e})}(n),{Fp:t}=e,o=(0,L.gN)(e.n,e.nBitLength),a=e.toBytes||((g,r,i)=>{const l=r.toAffine();return s.eV(Uint8Array.from([4]),t.toBytes(l.x),t.toBytes(l.y))}),f=e.fromBytes||(g=>{const r=g.subarray(1);return{x:t.fromBytes(r.subarray(0,t.BYTES)),y:t.fromBytes(r.subarray(t.BYTES,2*t.BYTES))}});function c(g){const{a:r,b:i}=e,l=t.sqr(g),u=t.mul(l,g);return t.add(t.add(u,t.mul(g,r)),i)}if(!t.eql(t.sqr(e.Gy),c(e.Gx)))throw new Error("bad generator point: equation left != right");function y(g){const{allowedPrivateKeyLengths:r,nByteLength:i,wrapPrivateKey:l,n:u}=e;if(r&&"bigint"!=typeof g){if(s._t(g)&&(g=s.ci(g)),"string"!=typeof g||!r.includes(g.length))throw new Error("invalid private key");g=g.padStart(2*i,"0")}let b;try{b="bigint"==typeof g?g:s.bytesToNumberBE((0,s.ql)("private key",g,i))}catch{throw new Error("invalid private key, expected hex or "+i+" bytes, got "+typeof g)}return l&&(b=(0,L.wQ)(b,u)),s.Fy("private key",b,N,u),b}function v(g){if(!(g instanceof w))throw new Error("ProjectivePoint expected")}const B=(0,s.H9)((g,r)=>{const{px:i,py:l,pz:u}=g;if(t.eql(u,t.ONE))return{x:i,y:l};const b=g.is0();null==r&&(r=b?t.ONE:t.inv(u));const R=t.mul(i,r),A=t.mul(l,r),E=t.mul(u,r);if(b)return{x:t.ZERO,y:t.ZERO};if(!t.eql(E,t.ONE))throw new Error("invZ was invalid");return{x:R,y:A}}),q=(0,s.H9)(g=>{if(g.is0()){if(e.allowInfinityPoint&&!t.is0(g.py))return;throw new Error("bad point: ZERO")}const{x:r,y:i}=g.toAffine();if(!t.isValid(r)||!t.isValid(i))throw new Error("bad point: x or y not FE");const l=t.sqr(i),u=c(r);if(!t.eql(l,u))throw new Error("bad point: equation left != right");if(!g.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});class w{constructor(r,i,l){if(this.px=r,this.py=i,this.pz=l,null==r||!t.isValid(r))throw new Error("x required");if(null==i||!t.isValid(i))throw new Error("y required");if(null==l||!t.isValid(l))throw new Error("z required");Object.freeze(this)}static fromAffine(r){const{x:i,y:l}=r||{};if(!r||!t.isValid(i)||!t.isValid(l))throw new Error("invalid affine point");if(r instanceof w)throw new Error("projective point not allowed");const u=b=>t.eql(b,t.ZERO);return u(i)&&u(l)?w.ZERO:new w(i,l,t.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(r){const i=t.invertBatch(r.map(l=>l.pz));return r.map((l,u)=>l.toAffine(i[u])).map(w.fromAffine)}static fromHex(r){const i=w.fromAffine(f((0,s.ql)("pointHex",r)));return i.assertValidity(),i}static fromPrivateKey(r){return w.BASE.multiply(y(r))}static msm(r,i){return(0,ht.D1)(w,o,r,i)}_setWindowSize(r){V.setWindowSize(this,r)}assertValidity(){q(this)}hasEvenY(){const{y:r}=this.toAffine();if(t.isOdd)return!t.isOdd(r);throw new Error("Field doesn't support isOdd")}equals(r){v(r);const{px:i,py:l,pz:u}=this,{px:b,py:R,pz:A}=r,E=t.eql(t.mul(i,A),t.mul(b,u)),S=t.eql(t.mul(l,A),t.mul(R,u));return E&&S}negate(){return new w(this.px,t.neg(this.py),this.pz)}double(){const{a:r,b:i}=e,l=t.mul(i,mt),{px:u,py:b,pz:R}=this;let A=t.ZERO,E=t.ZERO,S=t.ZERO,x=t.mul(u,u),Z=t.mul(b,b),H=t.mul(R,R),k=t.mul(u,b);return k=t.add(k,k),S=t.mul(u,R),S=t.add(S,S),A=t.mul(r,S),E=t.mul(l,H),E=t.add(A,E),A=t.sub(Z,E),E=t.add(Z,E),E=t.mul(A,E),A=t.mul(k,A),S=t.mul(l,S),H=t.mul(r,H),k=t.sub(x,H),k=t.mul(r,k),k=t.add(k,S),S=t.add(x,x),x=t.add(S,x),x=t.add(x,H),x=t.mul(x,k),E=t.add(E,x),H=t.mul(b,R),H=t.add(H,H),x=t.mul(H,k),A=t.sub(A,x),S=t.mul(H,Z),S=t.add(S,S),S=t.add(S,S),new w(A,E,S)}add(r){v(r);const{px:i,py:l,pz:u}=this,{px:b,py:R,pz:A}=r;let E=t.ZERO,S=t.ZERO,x=t.ZERO;const Z=e.a,H=t.mul(e.b,mt);let k=t.mul(i,b),z=t.mul(l,R),d=t.mul(u,A),h=t.add(i,l),m=t.add(b,R);h=t.mul(h,m),m=t.add(k,z),h=t.sub(h,m),m=t.add(i,u);let O=t.add(b,A);return m=t.mul(m,O),O=t.add(k,d),m=t.sub(m,O),O=t.add(l,u),E=t.add(R,A),O=t.mul(O,E),E=t.add(z,d),O=t.sub(O,E),x=t.mul(Z,m),E=t.mul(H,d),x=t.add(E,x),E=t.sub(z,x),x=t.add(z,x),S=t.mul(E,x),z=t.add(k,k),z=t.add(z,k),d=t.mul(Z,d),m=t.mul(H,m),z=t.add(z,d),d=t.sub(k,d),d=t.mul(Z,d),m=t.add(m,d),k=t.mul(z,m),S=t.add(S,k),k=t.mul(O,m),E=t.mul(h,E),E=t.sub(E,k),k=t.mul(h,z),x=t.mul(O,x),x=t.add(x,k),new w(E,S,x)}subtract(r){return this.add(r.negate())}is0(){return this.equals(w.ZERO)}wNAF(r){return V.wNAFCached(this,r,w.normalizeZ)}multiplyUnsafe(r){const{endo:i,n:l}=e;s.Fy("scalar",r,D,l);const u=w.ZERO;if(r===D)return u;if(this.is0()||r===N)return this;if(!i||V.hasPrecomputes(this))return V.wNAFCachedUnsafe(this,r,w.normalizeZ);let{k1neg:b,k1:R,k2neg:A,k2:E}=i.splitScalar(r),S=u,x=u,Z=this;for(;R>D||E>D;)R&N&&(S=S.add(Z)),E&N&&(x=x.add(Z)),Z=Z.double(),R>>=N,E>>=N;return b&&(S=S.negate()),A&&(x=x.negate()),x=new w(t.mul(x.px,i.beta),x.py,x.pz),S.add(x)}multiply(r){const{endo:i,n:l}=e;let u,b;if(s.Fy("scalar",r,N,l),i){const{k1neg:R,k1:A,k2neg:E,k2:S}=i.splitScalar(r);let{p:x,f:Z}=this.wNAF(A),{p:H,f:k}=this.wNAF(S);x=V.constTimeNegate(R,x),H=V.constTimeNegate(E,H),H=new w(t.mul(H.px,i.beta),H.py,H.pz),u=x.add(H),b=Z.add(k)}else{const{p:R,f:A}=this.wNAF(r);u=R,b=A}return w.normalizeZ([u,b])[0]}multiplyAndAddUnsafe(r,i,l){const u=w.BASE,b=(A,E)=>E!==D&&E!==N&&A.equals(u)?A.multiply(E):A.multiplyUnsafe(E),R=b(this,i).add(b(r,l));return R.is0()?void 0:R}toAffine(r){return B(this,r)}isTorsionFree(){const{h:r,isTorsionFree:i}=e;if(r===N)return!0;if(i)return i(w,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:r,clearCofactor:i}=e;return r===N?this:i?i(w,this):this.multiplyUnsafe(e.h)}toRawBytes(r=!0){return(0,s.uw)("isCompressed",r),this.assertValidity(),a(w,this,r)}toHex(r=!0){return(0,s.uw)("isCompressed",r),s.ci(this.toRawBytes(r))}}w.BASE=new w(e.Gx,e.Gy,t.ONE),w.ZERO=new w(t.ZERO,t.ONE,t.ZERO);const I=e.nBitLength,V=(0,ht.Mx)(w,e.endo?Math.ceil(I/2):I);return{CURVE:e,ProjectivePoint:w,normPrivateKeyToScalar:y,weierstrassEquation:c,isWithinCurveOrder:function p(g){return s.Z2(g,N,e.n)}}}function Qt(n){const e=function jt(n){const e=(0,ht.Kd)(n);return s.FF(e,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...e})}(n),{Fp:t,n:o}=e,a=t.BYTES+1,f=2*t.BYTES+1;function c(d){return(0,L.wQ)(d,o)}function p(d){return(0,L.U_)(d,o)}const{ProjectivePoint:y,normPrivateKeyToScalar:v,weierstrassEquation:B,isWithinCurveOrder:q}=Yt({...e,toBytes(d,h,m){const O=h.toAffine(),T=t.toBytes(O.x),P=s.eV;return(0,s.uw)("isCompressed",m),m?P(Uint8Array.from([h.hasEvenY()?2:3]),T):P(Uint8Array.from([4]),T,t.toBytes(O.y))},fromBytes(d){const h=d.length,m=d[0],O=d.subarray(1);if(h!==a||2!==m&&3!==m){if(h===f&&4===m){return{x:t.fromBytes(O.subarray(0,t.BYTES)),y:t.fromBytes(O.subarray(t.BYTES,2*t.BYTES))}}throw new Error("invalid Point, expected length of "+a+", or uncompressed "+f+", got "+h)}{const T=s.bytesToNumberBE(O);if(!s.Z2(T,N,t.ORDER))throw new Error("Point is not on curve");const P=B(T);let C;try{C=t.sqrt(P)}catch(K){const U=K instanceof Error?": "+K.message:"";throw new Error("Point is not on curve"+U)}return 1==(1&m)!==((C&N)===N)&&(C=t.neg(C)),{x:T,y:C}}}}),w=d=>s.ci(s.tL(d,e.nByteLength));function I(d){return d>o>>N}const g=(d,h,m)=>s.bytesToNumberBE(d.slice(h,m));class r{constructor(h,m,O){this.r=h,this.s=m,this.recovery=O,this.assertValidity()}static fromCompact(h){const m=e.nByteLength;return h=(0,s.ql)("compactSignature",h,2*m),new r(g(h,0,m),g(h,m,2*m))}static fromDER(h){const{r:m,s:O}=Y.toSig((0,s.ql)("DER",h));return new r(m,O)}assertValidity(){s.Fy("r",this.r,N,o),s.Fy("s",this.s,N,o)}addRecoveryBit(h){return new r(this.r,this.s,h)}recoverPublicKey(h){const{r:m,s:O,recovery:T}=this,P=A((0,s.ql)("msgHash",h));if(null==T||![0,1,2,3].includes(T))throw new Error("recovery id invalid");const C=2===T||3===T?m+e.n:m;if(C>=t.ORDER)throw new Error("recovery id 2 or 3 invalid");const _=1&T?"03":"02",j=y.fromHex(_+w(C)),K=p(C),U=c(-P*K),tt=c(O*K),X=y.BASE.multiplyAndAddUnsafe(j,U,tt);if(!X)throw new Error("point at infinify");return X.assertValidity(),X}hasHighS(){return I(this.s)}normalizeS(){return this.hasHighS()?new r(this.r,c(-this.s),this.recovery):this}toDERRawBytes(){return s.hexToBytes(this.toDERHex())}toDERHex(){return Y.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return s.hexToBytes(this.toCompactHex())}toCompactHex(){return w(this.r)+w(this.s)}}const i={isValidPrivateKey(d){try{return v(d),!0}catch{return!1}},normPrivateKeyToScalar:v,randomPrivateKey:()=>{const d=(0,L.PS)(e.n);return(0,L.Us)(e.randomBytes(d),e.n)},precompute:(d=8,h=y.BASE)=>(h._setWindowSize(d),h.multiply(BigInt(3)),h)};function u(d){const h=s._t(d),m="string"==typeof d,O=(h||m)&&d.length;return h?O===a||O===f:m?O===2*a||O===2*f:d instanceof y}const R=e.bits2int||function(d){if(d.length>8192)throw new Error("input is too large");const h=s.bytesToNumberBE(d),m=8*d.length-e.nBitLength;return m>0?h>>BigInt(m):h},A=e.bits2int_modN||function(d){return c(R(d))},E=s.dQ(e.nBitLength);function S(d){return s.Fy("num < 2^"+e.nBitLength,d,D,E),s.tL(d,e.nByteLength)}function x(d,h,m=Z){if(["recovered","canonical"].some(J=>J in m))throw new Error("sign() legacy options not supported");const{hash:O,randomBytes:T}=e;let{lowS:P,prehash:C,extraEntropy:_}=m;null==P&&(P=!0),d=(0,s.ql)("msgHash",d),qt(m),C&&(d=(0,s.ql)("prehashed msgHash",O(d)));const j=A(d),K=v(h),U=[S(K),S(j)];if(null!=_&&!1!==_){const J=!0===_?T(t.BYTES):_;U.push((0,s.ql)("extraEntropy",J))}const tt=s.eV(...U),X=j;return{seed:tt,k2sig:function Bt(J){const et=R(J);if(!q(et))return;const St=p(et),ft=y.BASE.multiply(et).toAffine(),$=c(ft.x);if($===D)return;const dt=c(St*c(X+$*K));if(dt===D)return;let nt=(ft.x===$?0:2)|Number(ft.y&N),Ct=dt;return P&&I(dt)&&(Ct=function V(d){return I(d)?c(-d):d}(dt),nt^=1),new r($,Ct,nt)}}}const Z={lowS:e.lowS,prehash:!1},H={lowS:e.lowS,prehash:!1};return y.BASE._setWindowSize(8),{CURVE:e,getPublicKey:function l(d,h=!0){return y.fromPrivateKey(d).toRawBytes(h)},getSharedSecret:function b(d,h,m=!0){if(u(d))throw new Error("first arg must be private key");if(!u(h))throw new Error("second arg must be public key");return y.fromHex(h).multiply(v(d)).toRawBytes(m)},sign:function k(d,h,m=Z){const{seed:O,k2sig:T}=x(d,h,m),P=e;return s.n$(P.hash.outputLen,P.nByteLength,P.hmac)(O,T)},verify:function z(d,h,m,O=H){const T=d;h=(0,s.ql)("msgHash",h),m=(0,s.ql)("publicKey",m);const{lowS:P,prehash:C,format:_}=O;if(qt(O),"strict"in O)throw new Error("options.strict was renamed to lowS");if(void 0!==_&&"compact"!==_&&"der"!==_)throw new Error("format must be compact or der");const j="string"==typeof T||s._t(T),K=!j&&!_&&"object"==typeof T&&null!==T&&"bigint"==typeof T.r&&"bigint"==typeof T.s;if(!j&&!K)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let U,tt;try{if(K&&(U=new r(T.r,T.s)),j){try{"compact"!==_&&(U=r.fromDER(T))}catch(nt){if(!(nt instanceof Y.Err))throw nt}!U&&"der"!==_&&(U=r.fromCompact(T))}tt=y.fromHex(m)}catch{return!1}if(!U||P&&U.hasHighS())return!1;C&&(h=e.hash(h));const{r:X,s:Bt}=U,J=A(h),et=p(Bt),St=c(J*et),ft=c(X*et),$=y.BASE.multiplyAndAddUnsafe(tt,St,ft)?.toAffine();return!!$&&c($.x)===X},ProjectivePoint:y,Signature:r,utils:i}}function Wt(n,e){if((0,L.OP)(n),!n.isValid(e.A)||!n.isValid(e.B)||!n.isValid(e.Z))throw new Error("mapToCurveSimpleSWU: invalid opts");const t=function Mt(n,e){const t=n.ORDER;let o=D;for(let V=t-N;V%M===D;V/=M)o+=N;const a=o,f=M<<a-N-N,c=f*M,p=(t-N)/c,y=(p-N)/M,v=c-N,B=f,q=n.pow(e,p),w=n.pow(e,(p+N)/M);let I=(V,g)=>{let r=q,i=n.pow(g,v),l=n.sqr(i);l=n.mul(l,g);let u=n.mul(V,l);u=n.pow(u,y),u=n.mul(u,i),i=n.mul(u,g),l=n.mul(u,V);let b=n.mul(l,i);u=n.pow(b,B);let R=n.eql(u,n.ONE);i=n.mul(l,w),u=n.mul(b,r),l=n.cmov(i,l,R),b=n.cmov(u,b,R);for(let A=a;A>N;A--){let E=A-M;E=M<<E-N;let S=n.pow(b,E);const x=n.eql(S,n.ONE);i=n.mul(l,r),r=n.mul(r,r),S=n.mul(b,r),l=n.cmov(i,l,x),b=n.cmov(S,b,x)}return{isValid:R,value:l}};if(n.ORDER%It===mt){const V=(n.ORDER-mt)/It,g=n.sqrt(n.neg(e));I=(r,i)=>{let l=n.sqr(i);const u=n.mul(r,i);l=n.mul(l,u);let b=n.pow(l,V);b=n.mul(b,u);const R=n.mul(b,g),A=n.mul(n.sqr(b),i),E=n.eql(A,r);return{isValid:E,value:n.cmov(R,b,E)}}}return I}(n,e.Z);if(!n.isOdd)throw new Error("Fp.isOdd is not implemented!");return o=>{let a,f,c,p,y,v,B,q;a=n.sqr(o),a=n.mul(a,e.Z),f=n.sqr(a),f=n.add(f,a),c=n.add(f,n.ONE),c=n.mul(c,e.B),p=n.cmov(e.Z,n.neg(f),!n.eql(f,n.ZERO)),p=n.mul(p,e.A),f=n.sqr(c),v=n.sqr(p),y=n.mul(v,e.A),f=n.add(f,y),f=n.mul(f,c),v=n.mul(v,p),y=n.mul(v,e.B),f=n.add(f,y),B=n.mul(a,c);const{isValid:w,value:I}=t(f,v);q=n.mul(a,o),q=n.mul(q,I),B=n.cmov(B,c,w),q=n.cmov(q,I,w);const V=n.isOdd(o)===n.isOdd(q);return q=n.cmov(n.neg(q),q,V),B=n.div(B,p),{x:B,y:q}}}function Gt(n){return{hash:n,hmac:(e,...t)=>Rt(n,e,(0,rt.eV)(...t)),randomBytes:rt.O6}}const Jt=s.bytesToNumberBE;function W(n,e){if(ot(n),ot(e),n<0||n>=1<<8*e)throw new Error("invalid I2OSP input: "+n);const t=Array.from({length:e}).fill(0);for(let o=e-1;o>=0;o--)t[o]=255&n,n>>>=8;return new Uint8Array(t)}function $t(n,e){const t=new Uint8Array(n.length);for(let o=0;o<n.length;o++)t[o]=n[o]^e[o];return t}function ot(n){if(!Number.isSafeInteger(n))throw new Error("number expected")}function Tt(n,e,t){(0,s.FF)(t,{DST:"stringOrUint8Array",p:"bigint",m:"isSafeInteger",k:"isSafeInteger",hash:"hash"});const{p:o,k:a,m:f,hash:c,expand:p,DST:y}=t;(0,s.gk)(n),ot(e);const v="string"==typeof y?(0,s.iY)(y):y,B=o.toString(2).length,q=Math.ceil((B+a)/8),w=e*f*q;let I;if("xmd"===p)I=function Ft(n,e,t,o){(0,s.gk)(n),(0,s.gk)(e),ot(t),e.length>255&&(e=o((0,s.eV)((0,s.iY)("H2C-OVERSIZE-DST-"),e)));const{outputLen:a,blockLen:f}=o,c=Math.ceil(t/a);if(t>65535||c>255)throw new Error("expand_message_xmd: invalid lenInBytes");const p=(0,s.eV)(e,W(e.length,1)),y=W(0,f),v=W(t,2),B=new Array(c),q=o((0,s.eV)(y,n,v,W(0,1),p));B[0]=o((0,s.eV)(q,W(1,1),p));for(let I=1;I<=c;I++){const V=[$t(q,B[I-1]),W(I+1,1),p];B[I]=o((0,s.eV)(...V))}return(0,s.eV)(...B).slice(0,t)}(n,v,w,c);else if("xof"===p)I=function te(n,e,t,o,a){if((0,s.gk)(n),(0,s.gk)(e),ot(t),e.length>255){const f=Math.ceil(2*o/8);e=a.create({dkLen:f}).update((0,s.iY)("H2C-OVERSIZE-DST-")).update(e).digest()}if(t>65535||e.length>255)throw new Error("expand_message_xof: invalid lenInBytes");return a.create({dkLen:t}).update(n).update(W(t,2)).update(e).update(W(e.length,1)).digest()}(n,v,w,a,c);else{if("_internal_pass"!==p)throw new Error('expand must be "xmd" or "xof"');I=n}const V=new Array(e);for(let g=0;g<e;g++){const r=new Array(f);for(let i=0;i<f;i++){const l=q*(i+g*f),u=I.subarray(l,l+q);r[i]=(0,L.wQ)(Jt(u),o)}V[g]=r}return V}const st=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),yt=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),it=BigInt(1),wt=BigInt(2),Nt=(n,e)=>(n+e/wt)/e;function kt(n){const e=st,t=BigInt(3),o=BigInt(6),a=BigInt(11),f=BigInt(22),c=BigInt(23),p=BigInt(44),y=BigInt(88),v=n*n*n%e,B=v*v*n%e,q=(0,L.oA)(B,t,e)*B%e,w=(0,L.oA)(q,t,e)*B%e,I=(0,L.oA)(w,wt,e)*v%e,V=(0,L.oA)(I,a,e)*I%e,g=(0,L.oA)(V,f,e)*V%e,r=(0,L.oA)(g,p,e)*g%e,i=(0,L.oA)(r,y,e)*r%e,l=(0,L.oA)(i,p,e)*g%e,u=(0,L.oA)(l,t,e)*B%e,b=(0,L.oA)(u,c,e)*V%e,R=(0,L.oA)(b,o,e)*v%e,A=(0,L.oA)(R,wt,e);if(!G.eql(G.sqr(A),n))throw new Error("Cannot find square root");return A}const G=(0,L.gN)(st,void 0,void 0,{sqrt:kt}),ct=function Xt(n,e){const t=o=>Qt({...n,...Gt(o)});return{...t(e),create:t}}({a:BigInt(0),b:BigInt(7),Fp:G,n:yt,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:n=>{const e=yt,t=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),o=-it*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),a=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),f=t,c=BigInt("0x100000000000000000000000000000000"),p=Nt(f*n,e),y=Nt(-o*n,e);let v=(0,L.wQ)(n-p*t-y*a,e),B=(0,L.wQ)(-p*o-y*f,e);const q=v>c,w=B>c;if(q&&(v=e-v),w&&(B=e-B),v>c||B>c)throw new Error("splitScalar: Endomorphism failed, k="+n);return{k1neg:q,k1:v,k2neg:w,k2:B}}}},lt.JQ),Vt=BigInt(0),Lt={};function gt(n,...e){let t=Lt[n];if(void 0===t){const o=(0,lt.JQ)(Uint8Array.from(n,a=>a.charCodeAt(0)));t=(0,s.eV)(o,o),Lt[n]=t}return(0,lt.JQ)((0,s.eV)(t,...e))}const bt=n=>n.toRawBytes(!0).slice(1),Et=n=>(0,s.tL)(n,32),pt=n=>(0,L.wQ)(n,st),at=n=>(0,L.wQ)(n,yt),vt=ct.ProjectivePoint,re=(n,e,t)=>vt.BASE.multiplyAndAddUnsafe(n,e,t);function xt(n){let e=ct.utils.normPrivateKeyToScalar(n),t=vt.fromPrivateKey(e);return{scalar:t.hasEvenY()?e:at(-e),bytes:bt(t)}}function Ht(n){(0,s.Fy)("x",n,it,st);const e=pt(n*n);let o=kt(pt(e*n+BigInt(7)));o%wt!==Vt&&(o=pt(-o));const a=new vt(n,o,it);return a.assertValidity(),a}const F=s.bytesToNumberBE;function Pt(...n){return at(F(gt("BIP0340/challenge",...n)))}function oe(n){return xt(n).bytes}function se(n,e,t=(0,rt.O6)(32)){const o=(0,s.ql)("message",n),{bytes:a,scalar:f}=xt(e),c=(0,s.ql)("auxRand",t,32),p=Et(f^F(gt("BIP0340/aux",c))),y=gt("BIP0340/nonce",p,a,o),v=at(F(y));if(v===Vt)throw new Error("sign failed: k is zero");const{bytes:B,scalar:q}=xt(v),w=Pt(B,a,o),I=new Uint8Array(64);if(I.set(B,0),I.set(Et(at(q+w*f)),32),!Zt(I,o,a))throw new Error("sign: Invalid signature produced");return I}function Zt(n,e,t){const o=(0,s.ql)("signature",n,64),a=(0,s.ql)("message",e),f=(0,s.ql)("publicKey",t,32);try{const c=Ht(F(f)),p=F(o.subarray(0,32));if(!(0,s.Z2)(p,it,st))return!1;const y=F(o.subarray(32,64));if(!(0,s.Z2)(y,it,yt))return!1;const v=Pt(Et(p),bt(c),a),B=re(c,y,at(-v));return!(!B||!B.hasEvenY()||B.toAffine().x!==p)}catch{return!1}}const ie=(()=>({getPublicKey:oe,sign:se,verify:Zt,utils:{randomPrivateKey:ct.utils.randomPrivateKey,lift_x:Ht,pointToBytes:bt,numberToBytesBE:s.tL,bytesToNumberBE:s.bytesToNumberBE,taggedHash:gt,mod:L.wQ}}))(),ce=(()=>function ee(n,e){const t=e.map(o=>Array.from(o).reverse());return(o,a)=>{const[f,c,p,y]=t.map(v=>v.reduce((B,q)=>n.add(n.mul(B,o),q)));return o=n.div(f,c),a=n.mul(a,n.div(p,y)),{x:o,y:a}}}(G,[["0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7","0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581","0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262","0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"],["0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b","0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14","0x0000000000000000000000000000000000000000000000000000000000000001"],["0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c","0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3","0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931","0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"],["0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b","0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573","0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f","0x0000000000000000000000000000000000000000000000000000000000000001"]].map(n=>n.map(e=>BigInt(e)))))(),ae=(()=>Wt(G,{A:BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),B:BigInt("1771"),Z:G.create(BigInt("-11"))}))(),_t=(()=>function ne(n,e,t){if("function"!=typeof e)throw new Error("mapToCurve() must be defined");return{hashToCurve(o,a){const f=Tt(o,2,{...t,DST:t.DST,...a}),c=n.fromAffine(e(f[0])),p=n.fromAffine(e(f[1])),y=c.add(p).clearCofactor();return y.assertValidity(),y},encodeToCurve(o,a){const f=Tt(o,1,{...t,DST:t.encodeDST,...a}),c=n.fromAffine(e(f[0])).clearCofactor();return c.assertValidity(),c},mapToCurve(o){if(!Array.isArray(o))throw new Error("mapToCurve: expected array of bigints");for(const f of o)if("bigint"!=typeof f)throw new Error("mapToCurve: expected array of bigints");const a=n.fromAffine(e(o)).clearCofactor();return a.assertValidity(),a}}}(ct.ProjectivePoint,n=>{const{x:e,y:t}=ae(G.create(n[0]));return ce(e,t)},{DST:"secp256k1_XMD:SHA-256_SSWU_RO_",encodeDST:"secp256k1_XMD:SHA-256_SSWU_NU_",p:G.ORDER,m:1,k:128,expand:"xmd",hash:lt.JQ}))(),fe=(()=>_t.hashToCurve)(),de=(()=>_t.encodeToCurve)()}}]);