"use strict";(self.webpackChunkangular=self.webpackChunkangular||[]).push([[341],{60341:(Bn,fe,Nt)=>{Nt.r(fe),Nt.d(fe,{encodeToCurve:()=>xn,hashToCurve:()=>vn,schnorr:()=>bn,secp256k1:()=>Ot,secp256k1_hasher:()=>ie});var Rt=Nt(70499),W=Nt(9949);class ae extends W.kb{constructor(n,e){super(),this.finished=!1,this.destroyed=!1,(0,W.z3)(n);const r=(0,W.O0)(e);if(this.iHash=n.create(),"function"!=typeof this.iHash.update)throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const s=this.blockLen,i=new Uint8Array(s);i.set(r.length>s?n.create().update(r).digest():r);for(let c=0;c<i.length;c++)i[c]^=54;this.iHash.update(i),this.oHash=n.create();for(let c=0;c<i.length;c++)i[c]^=106;this.oHash.update(i),(0,W.ru)(i)}update(n){return(0,W.$h)(this),this.iHash.update(n),this}digestInto(n){(0,W.$h)(this),(0,W.gk)(n,this.outputLen),this.finished=!0,this.iHash.digestInto(n),this.oHash.update(n),this.oHash.digestInto(n),this.destroy()}digest(){const n=new Uint8Array(this.oHash.outputLen);return this.digestInto(n),n}_cloneInto(n){n||(n=Object.create(Object.getPrototypeOf(this),{}));const{oHash:e,iHash:r,finished:s,destroyed:i,blockLen:c,outputLen:f}=this;return n.finished=s,n.destroyed=i,n.blockLen=c,n.outputLen=f,n.oHash=e._cloneInto(n.oHash),n.iHash=r._cloneInto(n.iHash),n}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const ue=(t,n,e)=>new ae(t,n).update(e).digest();ue.create=(t,n)=>new ae(t,n);const Tt=BigInt(0),wt=BigInt(1);function gt(t){return t instanceof Uint8Array||ArrayBuffer.isView(t)&&"Uint8Array"===t.constructor.name}function tt(t){if(!gt(t))throw new Error("Uint8Array expected")}function mt(t,n){if("boolean"!=typeof n)throw new Error(t+" boolean expected, got "+n)}function yt(t){const n=t.toString(16);return 1&n.length?"0"+n:n}function le(t){if("string"!=typeof t)throw new Error("hex string expected, got "+typeof t);return""===t?Tt:BigInt("0x"+t)}const de="function"==typeof Uint8Array.from([]).toHex&&"function"==typeof Uint8Array.fromHex,Pe=Array.from({length:256},(t,n)=>n.toString(16).padStart(2,"0"));function bt(t){if(tt(t),de)return t.toHex();let n="";for(let e=0;e<t.length;e++)n+=Pe[t[e]];return n}const J={_0:48,_9:57,A:65,F:70,a:97,f:102};function he(t){return t>=J._0&&t<=J._9?t-J._0:t>=J.A&&t<=J.F?t-(J.A-10):t>=J.a&&t<=J.f?t-(J.a-10):void 0}function Et(t){if("string"!=typeof t)throw new Error("hex string expected, got "+typeof t);if(de)return Uint8Array.fromHex(t);const n=t.length,e=n/2;if(n%2)throw new Error("hex string expected, got unpadded hex of length "+n);const r=new Uint8Array(e);for(let s=0,i=0;s<e;s++,i+=2){const c=he(t.charCodeAt(i)),f=he(t.charCodeAt(i+1));if(void 0===c||void 0===f){const o=t[i]+t[i+1];throw new Error('hex string expected, got non-hex character "'+o+'" at index '+i)}r[s]=16*c+f}return r}function Q(t){return le(bt(t))}function we(t){return tt(t),le(bt(Uint8Array.from(t).reverse()))}function it(t,n){return Et(t.toString(16).padStart(2*n,"0"))}function ge(t,n){return it(t,n).reverse()}function z(t,n,e){let r;if("string"==typeof n)try{r=Et(n)}catch(i){throw new Error(t+" must be hex string or Uint8Array, cause: "+i)}else{if(!gt(n))throw new Error(t+" must be hex string or Uint8Array");r=Uint8Array.from(n)}const s=r.length;if("number"==typeof e&&s!==e)throw new Error(t+" of length "+e+" expected, got "+s);return r}function Y(...t){let n=0;for(let r=0;r<t.length;r++){const s=t[r];tt(s),n+=s.length}const e=new Uint8Array(n);for(let r=0,s=0;r<t.length;r++){const i=t[r];e.set(i,s),s+=i.length}return e}function zt(t){if("string"!=typeof t)throw new Error("string expected");return new Uint8Array((new TextEncoder).encode(t))}const Pt=t=>"bigint"==typeof t&&Tt<=t;function pt(t,n,e){return Pt(t)&&Pt(n)&&Pt(e)&&n<=t&&t<e}function st(t,n,e,r){if(!pt(n,e,r))throw new Error("expected valid "+t+": "+e+" <= n < "+r+", got "+n)}const kt=t=>(wt<<BigInt(t))-wt,Mt=t=>new Uint8Array(t),me=t=>Uint8Array.from(t);const Ke={bigint:t=>"bigint"==typeof t,function:t=>"function"==typeof t,boolean:t=>"boolean"==typeof t,string:t=>"string"==typeof t,stringOrUint8Array:t=>"string"==typeof t||gt(t),isSafeInteger:t=>Number.isSafeInteger(t),array:t=>Array.isArray(t),field:(t,n)=>n.Fp.isValid(t),hash:t=>"function"==typeof t&&Number.isSafeInteger(t.outputLen)};function vt(t,n,e={}){const r=(s,i,c)=>{const f=Ke[i];if("function"!=typeof f)throw new Error("invalid validator function");const o=t[s];if(!(c&&void 0===o||f(o,t)))throw new Error("param "+String(s)+" is invalid. Expected "+i+", got "+o)};for(const[s,i]of Object.entries(n))r(s,i,!1);for(const[s,i]of Object.entries(e))r(s,i,!0);return t}function ye(t){const n=new WeakMap;return(e,...r)=>{const s=n.get(e);if(void 0!==s)return s;const i=t(e,...r);return n.set(e,i),i}}const M=BigInt(0),C=BigInt(1),ct=BigInt(2),Ye=BigInt(3),be=BigInt(4),Ee=BigInt(5),pe=BigInt(8);function V(t,n){const e=t%n;return e>=M?e:n+e}function D(t,n,e){let r=t;for(;n-- >M;)r*=r,r%=e;return r}function Lt(t,n){if(t===M)throw new Error("invert: expected non-zero number");if(n<=M)throw new Error("invert: expected positive modulus, got "+n);let e=V(t,n),r=n,s=M,i=C,c=C,f=M;for(;e!==M;){const u=r/e,l=r%e,w=s-c*u,b=i-f*u;r=e,e=l,s=c,i=f,c=w,f=b}if(r!==C)throw new Error("invert: does not exist");return V(s,n)}function ve(t,n){const e=(t.ORDER+C)/be,r=t.pow(n,e);if(!t.eql(t.sqr(r),n))throw new Error("Cannot find square root");return r}function De(t,n){const e=(t.ORDER-Ee)/pe,r=t.mul(n,ct),s=t.pow(r,e),i=t.mul(n,s),c=t.mul(t.mul(i,ct),s),f=t.mul(i,t.sub(c,t.ONE));if(!t.eql(t.sqr(f),n))throw new Error("Cannot find square root");return f}function Ge(t){return t%be===Ye?ve:t%pe===Ee?De:function We(t){if(t<BigInt(3))throw new Error("sqrt is not defined for small field");let n=t-C,e=0;for(;n%ct===M;)n/=ct,e++;let r=ct;const s=Ht(t);for(;1===jt(s,r);)if(r++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(1===e)return ve;let i=s.pow(r,n);const c=(n+C)/ct;return function(o,u){if(o.is0(u))return u;if(1!==jt(o,u))throw new Error("Cannot find square root");let l=e,w=o.mul(o.ONE,i),b=o.pow(u,n),y=o.pow(u,c);for(;!o.eql(b,o.ONE);){if(o.is0(b))return o.ZERO;let I=1,g=o.sqr(b);for(;!o.eql(g,o.ONE);)if(I++,g=o.sqr(g),I===l)throw new Error("Cannot find square root");const H=C<<BigInt(l-I-1),O=o.pow(w,H);l=I,w=o.sqr(O),b=o.mul(b,w),y=o.mul(y,O)}return y}}(t)}const Xe=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function xe(t){return vt(t,Xe.reduce((r,s)=>(r[s]="function",r),{ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"}))}function Be(t,n,e){if(e<M)throw new Error("invalid exponent, negatives unsupported");if(e===M)return t.ONE;if(e===C)return n;let r=t.ONE,s=n;for(;e>M;)e&C&&(r=t.mul(r,s)),s=t.sqr(s),e>>=C;return r}function Ut(t,n,e=!1){const r=new Array(n.length).fill(e?t.ZERO:void 0),s=n.reduce((c,f,o)=>t.is0(f)?c:(r[o]=c,t.mul(c,f)),t.ONE),i=t.inv(s);return n.reduceRight((c,f,o)=>t.is0(f)?c:(r[o]=t.mul(c,r[o]),t.mul(c,f)),i),r}function jt(t,n){const e=(t.ORDER-C)/ct,r=t.pow(n,e),s=t.eql(r,t.ONE),i=t.eql(r,t.ZERO),c=t.eql(r,t.neg(t.ONE));if(!s&&!i&&!c)throw new Error("invalid Legendre symbol result");return s?1:i?0:-1}function Kt(t,n){void 0!==n&&(0,W.k8)(n);const e=void 0!==n?n:t.toString(2).length;return{nBitLength:e,nByteLength:Math.ceil(e/8)}}function Ht(t,n,e=!1,r={}){if(t<=M)throw new Error("invalid field: expected ORDER > 0, got "+t);const{nBitLength:s,nByteLength:i}=Kt(t,n);if(i>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let c;const f=Object.freeze({ORDER:t,isLE:e,BITS:s,BYTES:i,MASK:kt(s),ZERO:M,ONE:C,create:o=>V(o,t),isValid:o=>{if("bigint"!=typeof o)throw new Error("invalid field element: expected bigint, got "+typeof o);return M<=o&&o<t},is0:o=>o===M,isOdd:o=>(o&C)===C,neg:o=>V(-o,t),eql:(o,u)=>o===u,sqr:o=>V(o*o,t),add:(o,u)=>V(o+u,t),sub:(o,u)=>V(o-u,t),mul:(o,u)=>V(o*u,t),pow:(o,u)=>Be(f,o,u),div:(o,u)=>V(o*Lt(u,t),t),sqrN:o=>o*o,addN:(o,u)=>o+u,subN:(o,u)=>o-u,mulN:(o,u)=>o*u,inv:o=>Lt(o,t),sqrt:r.sqrt||(o=>(c||(c=Ge(t)),c(f,o))),toBytes:o=>e?ge(o,i):it(o,i),fromBytes:o=>{if(o.length!==i)throw new Error("Field.fromBytes: expected "+i+" bytes, got "+o.length);return e?we(o):Q(o)},invertBatch:o=>Ut(f,o),cmov:(o,u,l)=>l?u:o});return Object.freeze(f)}function Se(t){if("bigint"!=typeof t)throw new Error("field order must be bigint");const n=t.toString(2).length;return Math.ceil(n/8)}function Ae(t){const n=Se(t);return n+Math.ceil(n/2)}const Oe=BigInt(0),Yt=BigInt(1);function Dt(t,n){const e=n.negate();return t?e:n}function Wt(t,n){if(!Number.isSafeInteger(t)||t<=0||t>n)throw new Error("invalid window size, expected [1.."+n+"], got W="+t)}function Gt(t,n){Wt(t,n);const s=2**t;return{windows:Math.ceil(n/t)+1,windowSize:2**(t-1),mask:kt(t),maxNumber:s,shiftBy:BigInt(t)}}function Ie(t,n,e){const{windowSize:r,mask:s,maxNumber:i,shiftBy:c}=e;let f=Number(t&s),o=t>>c;f>r&&(f-=i,o+=Yt);const u=n*r;return{nextN:o,offset:u+Math.abs(f)-1,isZero:0===f,isNeg:f<0,isNegF:n%2!=0,offsetF:u}}function _e(t,n){if(!Array.isArray(t))throw new Error("array expected");t.forEach((e,r)=>{if(!(e instanceof n))throw new Error("invalid point at index "+r)})}function qe(t,n){if(!Array.isArray(t))throw new Error("array of scalars expected");t.forEach((e,r)=>{if(!n.isValid(e))throw new Error("invalid scalar at index "+r)})}const Xt=new WeakMap,Ne=new WeakMap;function Qt(t){return Ne.get(t)||1}function $e(t,n,e,r){_e(e,t),qe(r,n);const s=e.length,i=r.length;if(s!==i)throw new Error("arrays of points and scalars must have equal length");const c=t.ZERO,f=function Me(t){let n;for(n=0;t>Tt;t>>=wt,n+=1);return n}(BigInt(s));let o=1;f>12?o=f-3:f>4?o=f-2:f>0&&(o=2);const u=kt(o),l=new Array(Number(u)+1).fill(c);let b=c;for(let y=Math.floor((n.BITS-1)/o)*o;y>=0;y-=o){l.fill(c);for(let g=0;g<i;g++){const H=r[g],O=Number(H>>BigInt(y)&u);l[O]=l[O].add(e[g])}let I=c;for(let g=l.length-1,H=c;g>0;g--)H=H.add(l[g]),I=I.add(H);if(b=b.add(I),0!==y)for(let g=0;g<o;g++)b=b.double()}return b}function Re(t){return xe(t.Fp),vt(t,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...Kt(t.n,t.nBitLength),...t,p:t.Fp.ORDER})}function Te(t){void 0!==t.lowS&&mt("lowS",t.lowS),void 0!==t.prehash&&mt("prehash",t.prehash)}class tn extends Error{constructor(n=""){super(n)}}const $={Err:tn,_tlv:{encode:(t,n)=>{const{Err:e}=$;if(t<0||t>256)throw new e("tlv.encode: wrong tag");if(1&n.length)throw new e("tlv.encode: unpadded data");const r=n.length/2,s=yt(r);if(s.length/2&128)throw new e("tlv.encode: long form length too big");const i=r>127?yt(s.length/2|128):"";return yt(t)+i+s+n},decode(t,n){const{Err:e}=$;let r=0;if(t<0||t>256)throw new e("tlv.encode: wrong tag");if(n.length<2||n[r++]!==t)throw new e("tlv.decode: wrong tlv");const s=n[r++];let c=0;if(!!(128&s)){const o=127&s;if(!o)throw new e("tlv.decode(long): indefinite length not supported");if(o>4)throw new e("tlv.decode(long): byte length is too big");const u=n.subarray(r,r+o);if(u.length!==o)throw new e("tlv.decode: length bytes not complete");if(0===u[0])throw new e("tlv.decode(long): zero leftmost byte");for(const l of u)c=c<<8|l;if(r+=o,c<128)throw new e("tlv.decode(long): not minimal encoding")}else c=s;const f=n.subarray(r,r+c);if(f.length!==c)throw new e("tlv.decode: wrong value length");return{v:f,l:n.subarray(r+c)}}},_int:{encode(t){const{Err:n}=$;if(t<G)throw new n("integer: negative integers are not allowed");let e=yt(t);if(8&Number.parseInt(e[0],16)&&(e="00"+e),1&e.length)throw new n("unexpected DER parsing assertion: unpadded hex");return e},decode(t){const{Err:n}=$;if(128&t[0])throw new n("invalid signature integer: negative");if(0===t[0]&&!(128&t[1]))throw new n("invalid signature integer: unnecessary leading zero");return Q(t)}},toSig(t){const{Err:n,_int:e,_tlv:r}=$,s=z("signature",t),{v:i,l:c}=r.decode(48,s);if(c.length)throw new n("invalid signature: left bytes after parsing");const{v:f,l:o}=r.decode(2,i),{v:u,l}=r.decode(2,o);if(l.length)throw new n("invalid signature: left bytes after parsing");return{r:e.decode(f),s:e.decode(u)}},hexFromSig(t){const{_tlv:n,_int:e}=$,i=n.encode(2,e.encode(t.r))+n.encode(2,e.encode(t.s));return n.encode(48,i)}};function Jt(t,n){return bt(it(t,n))}const G=BigInt(0),U=BigInt(1),et=BigInt(2),xt=BigInt(3),$t=BigInt(4);function en(t){const n=function Fe(t){const n=Re(t);vt(n,{a:"field",b:"field"},{allowInfinityPoint:"boolean",allowedPrivateKeyLengths:"array",clearCofactor:"function",fromBytes:"function",isTorsionFree:"function",toBytes:"function",wrapPrivateKey:"boolean"});const{endo:e,Fp:r,a:s}=n;if(e){if(!r.eql(s,r.ZERO))throw new Error("invalid endo: CURVE.a must be 0");if("object"!=typeof e||"bigint"!=typeof e.beta||"function"!=typeof e.splitScalar)throw new Error('invalid endo: expected "beta": bigint and "splitScalar": function')}return Object.freeze({...n})}(t),{Fp:e}=n,r=Ht(n.n,n.nBitLength),s=n.toBytes||((E,a,m)=>{const p=a.toAffine();return Y(Uint8Array.from([4]),e.toBytes(p.x),e.toBytes(p.y))}),i=n.fromBytes||(E=>{const a=E.subarray(1);return{x:e.fromBytes(a.subarray(0,e.BYTES)),y:e.fromBytes(a.subarray(e.BYTES,2*e.BYTES))}});function c(E){const{a,b:m}=n,p=e.sqr(E),x=e.mul(p,E);return e.add(e.add(x,e.mul(E,a)),m)}function f(E,a){const m=e.sqr(a),p=c(E);return e.eql(m,p)}if(!f(n.Gx,n.Gy))throw new Error("bad curve params: generator point");const o=e.mul(e.pow(n.a,xt),$t),u=e.mul(e.sqr(n.b),BigInt(27));if(e.is0(e.add(o,u)))throw new Error("bad curve params: a or b");function w(E){const{allowedPrivateKeyLengths:a,nByteLength:m,wrapPrivateKey:p,n:x}=n;if(a&&"bigint"!=typeof E){if(gt(E)&&(E=bt(E)),"string"!=typeof E||!a.includes(E.length))throw new Error("invalid private key");E=E.padStart(2*m,"0")}let _;try{_="bigint"==typeof E?E:Q(z("private key",E,m))}catch{throw new Error("invalid private key, expected hex or "+m+" bytes, got "+typeof E)}return p&&(_=V(_,x)),st("private key",_,U,x),_}function b(E){if(!(E instanceof g))throw new Error("ProjectivePoint expected")}const y=ye((E,a)=>{const{px:m,py:p,pz:x}=E;if(e.eql(x,e.ONE))return{x:m,y:p};const _=E.is0();null==a&&(a=_?e.ONE:e.inv(x));const k=e.mul(m,a),L=e.mul(p,a),B=e.mul(x,a);if(_)return{x:e.ZERO,y:e.ZERO};if(!e.eql(B,e.ONE))throw new Error("invZ was invalid");return{x:k,y:L}}),I=ye(E=>{if(E.is0()){if(n.allowInfinityPoint&&!e.is0(E.py))return;throw new Error("bad point: ZERO")}const{x:a,y:m}=E.toAffine();if(!e.isValid(a)||!e.isValid(m))throw new Error("bad point: x or y not FE");if(!f(a,m))throw new Error("bad point: equation left != right");if(!E.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});class g{constructor(a,m,p){if(null==a||!e.isValid(a))throw new Error("x required");if(null==m||!e.isValid(m)||e.is0(m))throw new Error("y required");if(null==p||!e.isValid(p))throw new Error("z required");this.px=a,this.py=m,this.pz=p,Object.freeze(this)}static fromAffine(a){const{x:m,y:p}=a||{};if(!a||!e.isValid(m)||!e.isValid(p))throw new Error("invalid affine point");if(a instanceof g)throw new Error("projective point not allowed");const x=_=>e.eql(_,e.ZERO);return x(m)&&x(p)?g.ZERO:new g(m,p,e.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(a){const m=Ut(e,a.map(p=>p.pz));return a.map((p,x)=>p.toAffine(m[x])).map(g.fromAffine)}static fromHex(a){const m=g.fromAffine(i(z("pointHex",a)));return m.assertValidity(),m}static fromPrivateKey(a){return g.BASE.multiply(w(a))}static msm(a,m){return $e(g,r,a,m)}_setWindowSize(a){T.setWindowSize(this,a)}assertValidity(){I(this)}hasEvenY(){const{y:a}=this.toAffine();if(e.isOdd)return!e.isOdd(a);throw new Error("Field doesn't support isOdd")}equals(a){b(a);const{px:m,py:p,pz:x}=this,{px:_,py:k,pz:L}=a,B=e.eql(e.mul(m,L),e.mul(_,x)),R=e.eql(e.mul(p,L),e.mul(k,x));return B&&R}negate(){return new g(this.px,e.neg(this.py),this.pz)}double(){const{a,b:m}=n,p=e.mul(m,xt),{px:x,py:_,pz:k}=this;let L=e.ZERO,B=e.ZERO,R=e.ZERO,S=e.mul(x,x),P=e.mul(_,_),h=e.mul(k,k),d=e.mul(x,_);return d=e.add(d,d),R=e.mul(x,k),R=e.add(R,R),L=e.mul(a,R),B=e.mul(p,h),B=e.add(L,B),L=e.sub(P,B),B=e.add(P,B),B=e.mul(L,B),L=e.mul(d,L),R=e.mul(p,R),h=e.mul(a,h),d=e.sub(S,h),d=e.mul(a,d),d=e.add(d,R),R=e.add(S,S),S=e.add(R,S),S=e.add(S,h),S=e.mul(S,d),B=e.add(B,S),h=e.mul(_,k),h=e.add(h,h),S=e.mul(h,d),L=e.sub(L,S),R=e.mul(h,P),R=e.add(R,R),R=e.add(R,R),new g(L,B,R)}add(a){b(a);const{px:m,py:p,pz:x}=this,{px:_,py:k,pz:L}=a;let B=e.ZERO,R=e.ZERO,S=e.ZERO;const P=n.a,h=e.mul(n.b,xt);let d=e.mul(m,_),v=e.mul(p,k),N=e.mul(x,L),A=e.add(m,p),q=e.add(_,k);A=e.mul(A,q),q=e.add(d,v),A=e.sub(A,q),q=e.add(m,x);let Z=e.add(_,L);return q=e.mul(q,Z),Z=e.add(d,N),q=e.sub(q,Z),Z=e.add(p,x),B=e.add(k,L),Z=e.mul(Z,B),B=e.add(v,N),Z=e.sub(Z,B),S=e.mul(P,q),B=e.mul(h,N),S=e.add(B,S),B=e.sub(v,S),S=e.add(v,S),R=e.mul(B,S),v=e.add(d,d),v=e.add(v,d),N=e.mul(P,N),q=e.mul(h,q),v=e.add(v,N),N=e.sub(d,N),N=e.mul(P,N),q=e.add(q,N),d=e.mul(v,q),R=e.add(R,d),d=e.mul(Z,q),B=e.mul(A,B),B=e.sub(B,d),d=e.mul(A,v),S=e.mul(Z,S),S=e.add(S,d),new g(B,R,S)}subtract(a){return this.add(a.negate())}is0(){return this.equals(g.ZERO)}wNAF(a){return T.wNAFCached(this,a,g.normalizeZ)}multiplyUnsafe(a){const{endo:m,n:p}=n;st("scalar",a,G,p);const x=g.ZERO;if(a===G)return x;if(this.is0()||a===U)return this;if(!m||T.hasPrecomputes(this))return T.wNAFCachedUnsafe(this,a,g.normalizeZ);let{k1neg:_,k1:k,k2neg:L,k2:B}=m.splitScalar(a),R=x,S=x,P=this;for(;k>G||B>G;)k&U&&(R=R.add(P)),B&U&&(S=S.add(P)),P=P.double(),k>>=U,B>>=U;return _&&(R=R.negate()),L&&(S=S.negate()),S=new g(e.mul(S.px,m.beta),S.py,S.pz),R.add(S)}multiply(a){const{endo:m,n:p}=n;let x,_;if(st("scalar",a,U,p),m){const{k1neg:k,k1:L,k2neg:B,k2:R}=m.splitScalar(a);let{p:S,f:P}=this.wNAF(L),{p:h,f:d}=this.wNAF(R);S=T.constTimeNegate(k,S),h=T.constTimeNegate(B,h),h=new g(e.mul(h.px,m.beta),h.py,h.pz),x=S.add(h),_=P.add(d)}else{const{p:k,f:L}=this.wNAF(a);x=k,_=L}return g.normalizeZ([x,_])[0]}multiplyAndAddUnsafe(a,m,p){const x=g.BASE,_=(L,B)=>B!==G&&B!==U&&L.equals(x)?L.multiply(B):L.multiplyUnsafe(B),k=_(this,m).add(_(a,p));return k.is0()?void 0:k}toAffine(a){return y(this,a)}isTorsionFree(){const{h:a,isTorsionFree:m}=n;if(a===U)return!0;if(m)return m(g,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:a,clearCofactor:m}=n;return a===U?this:m?m(g,this):this.multiplyUnsafe(n.h)}toRawBytes(a=!0){return mt("isCompressed",a),this.assertValidity(),s(g,this,a)}toHex(a=!0){return mt("isCompressed",a),bt(this.toRawBytes(a))}}g.BASE=new g(n.Gx,n.Gy,e.ONE),g.ZERO=new g(e.ZERO,e.ONE,e.ZERO);const{endo:H,nBitLength:O}=n,T=function Je(t,n){return{constTimeNegate:Dt,hasPrecomputes:e=>1!==Qt(e),unsafeLadder(e,r,s=t.ZERO){let i=e;for(;r>Oe;)r&Yt&&(s=s.add(i)),i=i.double(),r>>=Yt;return s},precomputeWindow(e,r){const{windows:s,windowSize:i}=Gt(r,n),c=[];let f=e,o=f;for(let u=0;u<s;u++){o=f,c.push(o);for(let l=1;l<i;l++)o=o.add(f),c.push(o);f=o.double()}return c},wNAF(e,r,s){let i=t.ZERO,c=t.BASE;const f=Gt(e,n);for(let o=0;o<f.windows;o++){const{nextN:u,offset:l,isZero:w,isNeg:b,isNegF:y,offsetF:I}=Ie(s,o,f);s=u,w?c=c.add(Dt(y,r[I])):i=i.add(Dt(b,r[l]))}return{p:i,f:c}},wNAFUnsafe(e,r,s,i=t.ZERO){const c=Gt(e,n);for(let f=0;f<c.windows&&s!==Oe;f++){const{nextN:o,offset:u,isZero:l,isNeg:w}=Ie(s,f,c);if(s=o,!l){const b=r[u];i=i.add(w?b.negate():b)}}return i},getPrecomputes(e,r,s){let i=Xt.get(r);return i||(i=this.precomputeWindow(r,e),1!==e&&Xt.set(r,s(i))),i},wNAFCached(e,r,s){const i=Qt(e);return this.wNAF(i,this.getPrecomputes(i,e,s),r)},wNAFCachedUnsafe(e,r,s,i){const c=Qt(e);return 1===c?this.unsafeLadder(e,r,i):this.wNAFUnsafe(c,this.getPrecomputes(c,e,s),r,i)},setWindowSize(e,r){Wt(r,n),Ne.set(e,r),Xt.delete(e)}}}(g,H?Math.ceil(O/2):O);return{CURVE:n,ProjectivePoint:g,normPrivateKeyToScalar:w,weierstrassEquation:c,isWithinCurveOrder:function l(E){return pt(E,U,n.n)}}}function rn(t){const n=function nn(t){const n=Re(t);return vt(n,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...n})}(t),{Fp:e,n:r,nByteLength:s,nBitLength:i}=n,c=e.BYTES+1,f=2*e.BYTES+1;function o(h){return V(h,r)}function u(h){return Lt(h,r)}const{ProjectivePoint:l,normPrivateKeyToScalar:w,weierstrassEquation:b,isWithinCurveOrder:y}=en({...n,toBytes(h,d,v){const N=d.toAffine(),A=e.toBytes(N.x),q=Y;return mt("isCompressed",v),v?q(Uint8Array.from([d.hasEvenY()?2:3]),A):q(Uint8Array.from([4]),A,e.toBytes(N.y))},fromBytes(h){const d=h.length,v=h[0],N=h.subarray(1);if(d!==c||2!==v&&3!==v){if(d===f&&4===v){return{x:e.fromBytes(N.subarray(0,e.BYTES)),y:e.fromBytes(N.subarray(e.BYTES,2*e.BYTES))}}throw new Error("invalid Point, expected length of "+c+", or uncompressed "+f+", got "+d)}{const A=Q(N);if(!pt(A,U,e.ORDER))throw new Error("Point is not on curve");const q=b(A);let Z;try{Z=e.sqrt(q)}catch(X){const K=X instanceof Error?": "+X.message:"";throw new Error("Point is not on curve"+K)}return 1==(1&v)!==((Z&U)===U)&&(Z=e.neg(Z)),{x:A,y:Z}}}});function I(h){return h>r>>U}const H=(h,d,v)=>Q(h.slice(d,v));class O{constructor(d,v,N){st("r",d,U,r),st("s",v,U,r),this.r=d,this.s=v,null!=N&&(this.recovery=N),Object.freeze(this)}static fromCompact(d){const v=s;return d=z("compactSignature",d,2*v),new O(H(d,0,v),H(d,v,2*v))}static fromDER(d){const{r:v,s:N}=$.toSig(z("DER",d));return new O(v,N)}assertValidity(){}addRecoveryBit(d){return new O(this.r,this.s,d)}recoverPublicKey(d){const{r:v,s:N,recovery:A}=this,q=x(z("msgHash",d));if(null==A||![0,1,2,3].includes(A))throw new Error("recovery id invalid");const Z=2===A||3===A?v+n.n:v;if(Z>=e.ORDER)throw new Error("recovery id 2 or 3 invalid");const j=1&A?"03":"02",F=l.fromHex(j+Jt(Z,e.BYTES)),X=u(Z),K=o(-q*X),lt=o(N*X),ot=l.BASE.multiplyAndAddUnsafe(F,K,lt);if(!ot)throw new Error("point at infinify");return ot.assertValidity(),ot}hasHighS(){return I(this.s)}normalizeS(){return this.hasHighS()?new O(this.r,o(-this.s),this.recovery):this}toDERRawBytes(){return Et(this.toDERHex())}toDERHex(){return $.hexFromSig(this)}toCompactRawBytes(){return Et(this.toCompactHex())}toCompactHex(){const d=s;return Jt(this.r,d)+Jt(this.s,d)}}const T={isValidPrivateKey(h){try{return w(h),!0}catch{return!1}},normPrivateKeyToScalar:w,randomPrivateKey:()=>{const h=Ae(n.n);return function Qe(t,n,e=!1){const r=t.length,s=Se(n),i=Ae(n);if(r<16||r<i||r>1024)throw new Error("expected "+i+"-1024 bytes of input, got "+r);const f=V(e?we(t):Q(t),n-C)+C;return e?ge(f,s):it(f,s)}(n.randomBytes(h),n.n)},precompute:(h=8,d=l.BASE)=>(d._setWindowSize(h),d.multiply(BigInt(3)),d)};function a(h){if("bigint"==typeof h)return!1;if(h instanceof l)return!0;const v=z("key",h).length,N=e.BYTES,A=N+1,q=2*N+1;return n.allowedPrivateKeyLengths||s===A?void 0:v===A||v===q}const p=n.bits2int||function(h){if(h.length>8192)throw new Error("input is too large");const d=Q(h),v=8*h.length-i;return v>0?d>>BigInt(v):d},x=n.bits2int_modN||function(h){return o(p(h))},_=kt(i);function k(h){return st("num < 2^"+i,h,G,_),it(h,s)}function L(h,d,v=B){if(["recovered","canonical"].some(ft=>ft in v))throw new Error("sign() legacy options not supported");const{hash:N,randomBytes:A}=n;let{lowS:q,prehash:Z,extraEntropy:j}=v;null==q&&(q=!0),h=z("msgHash",h),Te(v),Z&&(h=z("prehashed msgHash",N(h)));const F=x(h),X=w(d),K=[k(X),k(F)];if(null!=j&&!1!==j){const ft=!0===j?A(e.BYTES):j;K.push(z("extraEntropy",ft))}const lt=Y(...K),ot=F;return{seed:lt,k2sig:function se(ft){const dt=p(ft);if(!y(dt))return;const ce=u(dt),_t=l.BASE.multiply(dt).toAffine(),at=o(_t.x);if(at===G)return;const qt=o(ce*o(ot+at*X));if(qt===G)return;let ht=(_t.x===at?0:2)|Number(_t.y&U),ze=qt;return q&&I(qt)&&(ze=function g(h){return I(h)?o(-h):h}(qt),ht^=1),new O(at,ze,ht)}}}const B={lowS:n.lowS,prehash:!1},R={lowS:n.lowS,prehash:!1};return l.BASE._setWindowSize(8),{CURVE:n,getPublicKey:function E(h,d=!0){return l.fromPrivateKey(h).toRawBytes(d)},getSharedSecret:function m(h,d,v=!0){if(!0===a(h))throw new Error("first arg must be private key");if(!1===a(d))throw new Error("second arg must be public key");return l.fromHex(d).multiply(w(h)).toRawBytes(v)},sign:function S(h,d,v=B){const{seed:N,k2sig:A}=L(h,d,v),q=n;return function je(t,n,e){if("number"!=typeof t||t<2)throw new Error("hashLen must be a number");if("number"!=typeof n||n<2)throw new Error("qByteLen must be a number");if("function"!=typeof e)throw new Error("hmacFn must be a function");let r=Mt(t),s=Mt(t),i=0;const c=()=>{r.fill(1),s.fill(0),i=0},f=(...w)=>e(s,r,...w),o=(w=Mt(0))=>{s=f(me([0]),w),r=f(),0!==w.length&&(s=f(me([1]),w),r=f())},u=()=>{if(i++>=1e3)throw new Error("drbg: tried 1000 values");let w=0;const b=[];for(;w<n;){r=f();const y=r.slice();b.push(y),w+=r.length}return Y(...b)};return(w,b)=>{let y;for(c(),o(w);!(y=b(u()));)o();return c(),y}}(q.hash.outputLen,q.nByteLength,q.hmac)(N,A)},verify:function P(h,d,v,N=R){const A=h;d=z("msgHash",d),v=z("publicKey",v);const{lowS:q,prehash:Z,format:j}=N;if(Te(N),"strict"in N)throw new Error("options.strict was renamed to lowS");if(void 0!==j&&"compact"!==j&&"der"!==j)throw new Error("format must be compact or der");const F="string"==typeof A||gt(A),X=!F&&!j&&"object"==typeof A&&null!==A&&"bigint"==typeof A.r&&"bigint"==typeof A.s;if(!F&&!X)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let K,lt;try{if(X&&(K=new O(A.r,A.s)),F){try{"compact"!==j&&(K=O.fromDER(A))}catch(ht){if(!(ht instanceof $.Err))throw ht}!K&&"der"!==j&&(K=O.fromCompact(A))}lt=l.fromHex(v)}catch{return!1}if(!K||q&&K.hasHighS())return!1;Z&&(d=n.hash(d));const{r:ot,s:se}=K,ft=x(d),dt=u(se),ce=o(ft*dt),_t=o(ot*dt),at=l.BASE.multiplyAndAddUnsafe(lt,ce,_t)?.toAffine();return!!at&&o(at.x)===ot},ProjectivePoint:l,Signature:O,utils:T}}function sn(t,n){if(xe(t),!t.isValid(n.A)||!t.isValid(n.B)||!t.isValid(n.Z))throw new Error("mapToCurveSimpleSWU: invalid opts");const e=function on(t,n){const e=t.ORDER;let r=G;for(let I=e-U;I%et===G;I/=et)r+=U;const s=r,i=et<<s-U-U,c=i*et,f=(e-U)/c,o=(f-U)/et,u=c-U,l=i,w=t.pow(n,f),b=t.pow(n,(f+U)/et);let y=(I,g)=>{let H=w,O=t.pow(g,u),T=t.sqr(O);T=t.mul(T,g);let E=t.mul(I,T);E=t.pow(E,o),E=t.mul(E,O),O=t.mul(E,g),T=t.mul(E,I);let a=t.mul(T,O);E=t.pow(a,l);let m=t.eql(E,t.ONE);O=t.mul(T,b),E=t.mul(a,H),T=t.cmov(O,T,m),a=t.cmov(E,a,m);for(let p=s;p>U;p--){let x=p-et;x=et<<x-U;let _=t.pow(a,x);const k=t.eql(_,t.ONE);O=t.mul(T,H),H=t.mul(H,H),_=t.mul(a,H),T=t.cmov(O,T,k),a=t.cmov(_,a,k)}return{isValid:m,value:T}};if(t.ORDER%$t===xt){const I=(t.ORDER-xt)/$t,g=t.sqrt(t.neg(n));y=(H,O)=>{let T=t.sqr(O);const E=t.mul(H,O);T=t.mul(T,E);let a=t.pow(T,I);a=t.mul(a,E);const m=t.mul(a,g),p=t.mul(t.sqr(a),O),x=t.eql(p,H);return{isValid:x,value:t.cmov(m,a,x)}}}return y}(t,n.Z);if(!t.isOdd)throw new Error("Fp.isOdd is not implemented!");return r=>{let s,i,c,f,o,u,l,w;s=t.sqr(r),s=t.mul(s,n.Z),i=t.sqr(s),i=t.add(i,s),c=t.add(i,t.ONE),c=t.mul(c,n.B),f=t.cmov(n.Z,t.neg(i),!t.eql(i,t.ZERO)),f=t.mul(f,n.A),i=t.sqr(c),u=t.sqr(f),o=t.mul(u,n.A),i=t.add(i,o),i=t.mul(i,c),u=t.mul(u,f),o=t.mul(u,n.B),i=t.add(i,o),l=t.mul(s,c);const{isValid:b,value:y}=e(i,u);w=t.mul(s,r),w=t.mul(w,y),l=t.cmov(l,c,b),w=t.cmov(w,y,b);const I=t.isOdd(r)===t.isOdd(w);w=t.cmov(t.neg(w),w,I);const g=Ut(t,[f],!0)[0];return l=t.mul(l,g),{x:l,y:w}}}function cn(t){return{hash:t,hmac:(n,...e)=>ue(t,n,(0,W.eV)(...e)),randomBytes:W.O6}}const an=Q;function nt(t,n){if(Bt(t),Bt(n),t<0||t>=1<<8*n)throw new Error("invalid I2OSP input: "+t);const e=Array.from({length:n}).fill(0);for(let r=n-1;r>=0;r--)e[r]=255&t,t>>>=8;return new Uint8Array(e)}function un(t,n){const e=new Uint8Array(t.length);for(let r=0;r<t.length;r++)e[r]=t[r]^n[r];return e}function Bt(t){if(!Number.isSafeInteger(t))throw new Error("number expected")}function ke(t,n,e){vt(e,{DST:"stringOrUint8Array",p:"bigint",m:"isSafeInteger",k:"isSafeInteger",hash:"hash"});const{p:r,k:s,m:i,hash:c,expand:f,DST:o}=e;tt(t),Bt(n);const u="string"==typeof o?zt(o):o,l=r.toString(2).length,w=Math.ceil((l+s)/8),b=n*i*w;let y;if("xmd"===f)y=function ln(t,n,e,r){tt(t),tt(n),Bt(e),n.length>255&&(n=r(Y(zt("H2C-OVERSIZE-DST-"),n)));const{outputLen:s,blockLen:i}=r,c=Math.ceil(e/s);if(e>65535||c>255)throw new Error("expand_message_xmd: invalid lenInBytes");const f=Y(n,nt(n.length,1)),o=nt(0,i),u=nt(e,2),l=new Array(c),w=r(Y(o,t,u,nt(0,1),f));l[0]=r(Y(w,nt(1,1),f));for(let y=1;y<=c;y++){const I=[un(w,l[y-1]),nt(y+1,1),f];l[y]=r(Y(...I))}return Y(...l).slice(0,e)}(t,u,b,c);else if("xof"===f)y=function dn(t,n,e,r,s){if(tt(t),tt(n),Bt(e),n.length>255){const i=Math.ceil(2*r/8);n=s.create({dkLen:i}).update(zt("H2C-OVERSIZE-DST-")).update(n).digest()}if(e>65535||n.length>255)throw new Error("expand_message_xof: invalid lenInBytes");return s.create({dkLen:e}).update(t).update(nt(e,2)).update(n).update(nt(n.length,1)).digest()}(t,u,b,s,c);else{if("_internal_pass"!==f)throw new Error('expand must be "xmd" or "xof"');y=t}const I=new Array(n);for(let g=0;g<n;g++){const H=new Array(i);for(let O=0;O<i;O++){const T=w*(O+g*i),E=y.subarray(T,T+w);H[O]=V(an(E),r)}I[g]=H}return I}const St=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),Zt=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),Ft=BigInt(0),At=BigInt(1),Ct=BigInt(2),Le=(t,n)=>(t+n/Ct)/n;function Ue(t){const n=St,e=BigInt(3),r=BigInt(6),s=BigInt(11),i=BigInt(22),c=BigInt(23),f=BigInt(44),o=BigInt(88),u=t*t*t%n,l=u*u*t%n,w=D(l,e,n)*l%n,b=D(w,e,n)*l%n,y=D(b,Ct,n)*u%n,I=D(y,s,n)*y%n,g=D(I,i,n)*I%n,H=D(g,f,n)*g%n,O=D(H,o,n)*H%n,T=D(O,f,n)*g%n,E=D(T,e,n)*l%n,a=D(E,c,n)*I%n,m=D(a,r,n)*u%n,p=D(m,Ct,n);if(!rt.eql(rt.sqr(p),t))throw new Error("Cannot find square root");return p}const rt=Ht(St,void 0,void 0,{sqrt:Ue}),Ot=function fn(t,n){const e=r=>rn({...t,...cn(r)});return{...e(n),create:e}}({a:Ft,b:BigInt(7),Fp:rt,n:Zt,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:t=>{const n=Zt,e=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),r=-At*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),s=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),i=e,c=BigInt("0x100000000000000000000000000000000"),f=Le(i*t,n),o=Le(-r*t,n);let u=V(t-f*e-o*s,n),l=V(-f*r-o*i,n);const w=u>c,b=l>c;if(w&&(u=n-u),b&&(l=n-l),u>c||l>c)throw new Error("splitScalar: Endomorphism failed, k="+t);return{k1neg:w,k1:u,k2neg:b,k2:l}}}},Rt.JQ),He={};function Vt(t,...n){let e=He[t];if(void 0===e){const r=(0,Rt.JQ)(Uint8Array.from(t,s=>s.charCodeAt(0)));e=Y(r,r),He[t]=e}return(0,Rt.JQ)(Y(e,...n))}const te=t=>t.toRawBytes(!0).slice(1),ee=t=>it(t,32),ne=t=>V(t,St),It=t=>V(t,Zt),re=(()=>Ot.ProjectivePoint)(),gn=(t,n,e)=>re.BASE.multiplyAndAddUnsafe(t,n,e);function oe(t){let n=Ot.utils.normPrivateKeyToScalar(t),e=re.fromPrivateKey(n);return{scalar:e.hasEvenY()?n:It(-n),bytes:te(e)}}function Ze(t){st("x",t,At,St);const n=ne(t*t);let r=Ue(ne(n*t+BigInt(7)));r%Ct!==Ft&&(r=ne(-r));const s=new re(t,r,At);return s.assertValidity(),s}const ut=Q;function Ce(...t){return It(ut(Vt("BIP0340/challenge",...t)))}function mn(t){return oe(t).bytes}function yn(t,n,e=(0,W.O6)(32)){const r=z("message",t),{bytes:s,scalar:i}=oe(n),c=z("auxRand",e,32),f=ee(i^ut(Vt("BIP0340/aux",c))),o=Vt("BIP0340/nonce",f,s,r),u=It(ut(o));if(u===Ft)throw new Error("sign failed: k is zero");const{bytes:l,scalar:w}=oe(u),b=Ce(l,s,r),y=new Uint8Array(64);if(y.set(l,0),y.set(ee(It(w+b*i)),32),!Ve(y,r,s))throw new Error("sign: Invalid signature produced");return y}function Ve(t,n,e){const r=z("signature",t,64),s=z("message",n),i=z("publicKey",e,32);try{const c=Ze(ut(i)),f=ut(r.subarray(0,32));if(!pt(f,At,St))return!1;const o=ut(r.subarray(32,64));if(!pt(o,At,Zt))return!1;const u=Ce(ee(f),te(c),s),l=gn(c,o,It(-u));return!(!l||!l.hasEvenY()||l.toAffine().x!==f)}catch{return!1}}const bn=(()=>({getPublicKey:mn,sign:yn,verify:Ve,utils:{randomPrivateKey:Ot.utils.randomPrivateKey,lift_x:Ze,pointToBytes:te,numberToBytesBE:it,bytesToNumberBE:Q,taggedHash:Vt,mod:V}}))(),En=(()=>function hn(t,n){const e=n.map(r=>Array.from(r).reverse());return(r,s)=>{const[i,c,f,o]=e.map(w=>w.reduce((b,y)=>t.add(t.mul(b,r),y))),[u,l]=Ut(t,[c,o],!0);return r=t.mul(i,u),s=t.mul(s,t.mul(f,l)),{x:r,y:s}}}(rt,[["0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7","0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581","0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262","0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"],["0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b","0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14","0x0000000000000000000000000000000000000000000000000000000000000001"],["0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c","0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3","0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931","0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"],["0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b","0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573","0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f","0x0000000000000000000000000000000000000000000000000000000000000001"]].map(t=>t.map(n=>BigInt(n)))))(),pn=(()=>sn(rt,{A:BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),B:BigInt("1771"),Z:rt.create(BigInt("-11"))}))(),ie=(()=>function wn(t,n,e){if("function"!=typeof n)throw new Error("mapToCurve() must be defined");function r(i){return t.fromAffine(n(i))}function s(i){const c=i.clearCofactor();return c.equals(t.ZERO)?t.ZERO:(c.assertValidity(),c)}return{defaults:e,hashToCurve(i,c){const f=ke(i,2,{...e,DST:e.DST,...c}),o=r(f[0]),u=r(f[1]);return s(o.add(u))},encodeToCurve:(i,c)=>s(r(ke(i,1,{...e,DST:e.encodeDST,...c})[0])),mapToCurve(i){if(!Array.isArray(i))throw new Error("expected array of bigints");for(const c of i)if("bigint"!=typeof c)throw new Error("expected array of bigints");return s(r(i))}}}(Ot.ProjectivePoint,t=>{const{x:n,y:e}=pn(rt.create(t[0]));return En(n,e)},{DST:"secp256k1_XMD:SHA-256_SSWU_RO_",encodeDST:"secp256k1_XMD:SHA-256_SSWU_NU_",p:rt.ORDER,m:1,k:128,expand:"xmd",hash:Rt.JQ}))(),vn=(()=>ie.hashToCurve)(),xn=(()=>ie.encodeToCurve)()}}]);