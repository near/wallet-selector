"use strict";(self.webpackChunkangular=self.webpackChunkangular||[]).push([[1949],{1949:(Rn,be,Kt)=>{Kt.r(be),Kt.d(be,{encodeToCurve:()=>Tn,hashToCurve:()=>Cn,schnorr:()=>Ln,secp256k1:()=>Lt,secp256k1_hasher:()=>ue});var T=Kt(71971);function We(t,n,e){return t&n^~t&e}function Xe(t,n,e){return t&n^t&e^n&e}class Qe extends T.kb{constructor(n,e,r,s){super(),this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.blockLen=n,this.outputLen=e,this.padOffset=r,this.isLE=s,this.buffer=new Uint8Array(n),this.view=(0,T.GL)(this.buffer)}update(n){(0,T.$h)(this),n=(0,T.O0)(n),(0,T.gk)(n);const{view:e,buffer:r,blockLen:s}=this,o=n.length;for(let c=0;c<o;){const f=Math.min(s-this.pos,o-c);if(f!==s)r.set(n.subarray(c,c+f),this.pos),this.pos+=f,c+=f,this.pos===s&&(this.process(e,0),this.pos=0);else{const i=(0,T.GL)(n);for(;s<=o-c;c+=s)this.process(i,c)}}return this.length+=n.length,this.roundClean(),this}digestInto(n){(0,T.$h)(this),(0,T.eB)(n,this),this.finished=!0;const{buffer:e,view:r,blockLen:s,isLE:o}=this;let{pos:c}=this;e[c++]=128,(0,T.ru)(this.buffer.subarray(c)),this.padOffset>s-c&&(this.process(r,0),c=0);for(let l=c;l<s;l++)e[l]=0;(function Ye(t,n,e,r){if("function"==typeof t.setBigUint64)return t.setBigUint64(n,e,r);const s=BigInt(32),o=BigInt(4294967295),c=Number(e>>s&o),f=Number(e&o),i=r?4:0,a=r?0:4;t.setUint32(n+i,c,r),t.setUint32(n+a,f,r)})(r,s-8,BigInt(8*this.length),o),this.process(r,0);const f=(0,T.GL)(n),i=this.outputLen;if(i%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const a=i/4,d=this.get();if(a>d.length)throw new Error("_sha2: outputLen bigger than state");for(let l=0;l<a;l++)f.setUint32(4*l,d[l],o)}digest(){const{buffer:n,outputLen:e}=this;this.digestInto(n);const r=n.slice(0,e);return this.destroy(),r}_cloneInto(n){n||(n=new this.constructor),n.set(...this.get());const{blockLen:e,buffer:r,length:s,finished:o,destroyed:c,pos:f}=this;return n.destroyed=c,n.finished=o,n.length=s,n.pos=f,s%e&&n.buffer.set(r),n}clone(){return this._cloneInto()}}const nt=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),$e=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),rt=new Uint32Array(64);class Je extends Qe{constructor(n=32){super(64,n,8,!1),this.A=0|nt[0],this.B=0|nt[1],this.C=0|nt[2],this.D=0|nt[3],this.E=0|nt[4],this.F=0|nt[5],this.G=0|nt[6],this.H=0|nt[7]}get(){const{A:n,B:e,C:r,D:s,E:o,F:c,G:f,H:i}=this;return[n,e,r,s,o,c,f,i]}set(n,e,r,s,o,c,f,i){this.A=0|n,this.B=0|e,this.C=0|r,this.D=0|s,this.E=0|o,this.F=0|c,this.G=0|f,this.H=0|i}process(n,e){for(let l=0;l<16;l++,e+=4)rt[l]=n.getUint32(e,!1);for(let l=16;l<64;l++){const b=rt[l-15],y=rt[l-2],E=(0,T.np)(b,7)^(0,T.np)(b,18)^b>>>3,h=(0,T.np)(y,17)^(0,T.np)(y,19)^y>>>10;rt[l]=h+rt[l-7]+E+rt[l-16]|0}let{A:r,B:s,C:o,D:c,E:f,F:i,G:a,H:d}=this;for(let l=0;l<64;l++){const y=d+((0,T.np)(f,6)^(0,T.np)(f,11)^(0,T.np)(f,25))+We(f,i,a)+$e[l]+rt[l]|0,h=((0,T.np)(r,2)^(0,T.np)(r,13)^(0,T.np)(r,22))+Xe(r,s,o)|0;d=a,a=i,i=f,f=c+y|0,c=o,o=s,s=r,r=y+h|0}r=r+this.A|0,s=s+this.B|0,o=o+this.C|0,c=c+this.D|0,f=f+this.E|0,i=i+this.F|0,a=a+this.G|0,d=d+this.H|0,this.set(r,s,o,c,f,i,a,d)}roundClean(){(0,T.ru)(rt)}destroy(){this.set(0,0,0,0,0,0,0,0),(0,T.ru)(this.buffer)}}const Tt=(0,T.V1)(()=>new Je);class xe extends T.kb{constructor(n,e){super(),this.finished=!1,this.destroyed=!1,(0,T.z3)(n);const r=(0,T.O0)(e);if(this.iHash=n.create(),"function"!=typeof this.iHash.update)throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const s=this.blockLen,o=new Uint8Array(s);o.set(r.length>s?n.create().update(r).digest():r);for(let c=0;c<o.length;c++)o[c]^=54;this.iHash.update(o),this.oHash=n.create();for(let c=0;c<o.length;c++)o[c]^=106;this.oHash.update(o),(0,T.ru)(o)}update(n){return(0,T.$h)(this),this.iHash.update(n),this}digestInto(n){(0,T.$h)(this),(0,T.gk)(n,this.outputLen),this.finished=!0,this.iHash.digestInto(n),this.oHash.update(n),this.oHash.digestInto(n),this.destroy()}digest(){const n=new Uint8Array(this.oHash.outputLen);return this.digestInto(n),n}_cloneInto(n){n||(n=Object.create(Object.getPrototypeOf(this),{}));const{oHash:e,iHash:r,finished:s,destroyed:o,blockLen:c,outputLen:f}=this;return n.finished=s,n.destroyed=o,n.blockLen=c,n.outputLen=f,n.oHash=e._cloneInto(n.oHash),n.iHash=r._cloneInto(n.iHash),n}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const ge=(t,n,e)=>new xe(t,n).update(e).digest();ge.create=(t,n)=>new xe(t,n);const Rt=BigInt(0),pt=BigInt(1);function Et(t){return t instanceof Uint8Array||ArrayBuffer.isView(t)&&"Uint8Array"===t.constructor.name}function it(t){if(!Et(t))throw new Error("Uint8Array expected")}function St(t,n){if("boolean"!=typeof n)throw new Error(t+" boolean expected, got "+n)}function At(t){const n=t.toString(16);return 1&n.length?"0"+n:n}function we(t){if("string"!=typeof t)throw new Error("hex string expected, got "+typeof t);return""===t?Rt:BigInt("0x"+t)}const me="function"==typeof Uint8Array.from([]).toHex&&"function"==typeof Uint8Array.fromHex,en=Array.from({length:256},(t,n)=>n.toString(16).padStart(2,"0"));function Bt(t){if(it(t),me)return t.toHex();let n="";for(let e=0;e<t.length;e++)n+=en[t[e]];return n}const F={_0:48,_9:57,A:65,F:70,a:97,f:102};function ye(t){return t>=F._0&&t<=F._9?t-F._0:t>=F.A&&t<=F.F?t-(F.A-10):t>=F.a&&t<=F.f?t-(F.a-10):void 0}function vt(t){if("string"!=typeof t)throw new Error("hex string expected, got "+typeof t);if(me)return Uint8Array.fromHex(t);const n=t.length,e=n/2;if(n%2)throw new Error("hex string expected, got unpadded hex of length "+n);const r=new Uint8Array(e);for(let s=0,o=0;s<e;s++,o+=2){const c=ye(t.charCodeAt(o)),f=ye(t.charCodeAt(o+1));if(void 0===c||void 0===f){const i=t[o]+t[o+1];throw new Error('hex string expected, got non-hex character "'+i+'" at index '+o)}r[s]=16*c+f}return r}function J(t){return we(Bt(t))}function pe(t){return it(t),we(Bt(Uint8Array.from(t).reverse()))}function ut(t,n){return vt(t.toString(16).padStart(2*n,"0"))}function Ee(t,n){return ut(t,n).reverse()}function G(t,n,e){let r;if("string"==typeof n)try{r=vt(n)}catch(o){throw new Error(t+" must be hex string or Uint8Array, cause: "+o)}else{if(!Et(n))throw new Error(t+" must be hex string or Uint8Array");r=Uint8Array.from(n)}const s=r.length;if("number"==typeof e&&s!==e)throw new Error(t+" of length "+e+" expected, got "+s);return r}function W(...t){let n=0;for(let r=0;r<t.length;r++){const s=t[r];it(s),n+=s.length}const e=new Uint8Array(n);for(let r=0,s=0;r<t.length;r++){const o=t[r];e.set(o,s),s+=o.length}return e}function jt(t){if("string"!=typeof t)throw new Error("string expected");return new Uint8Array((new TextEncoder).encode(t))}const Yt=t=>"bigint"==typeof t&&Rt<=t;function _t(t,n,e){return Yt(t)&&Yt(n)&&Yt(e)&&n<=t&&t<e}function dt(t,n,e,r){if(!_t(n,e,r))throw new Error("expected valid "+t+": "+e+" <= n < "+r+", got "+n)}const kt=t=>(pt<<BigInt(t))-pt,Wt=t=>new Uint8Array(t),Se=t=>Uint8Array.from(t);const sn={bigint:t=>"bigint"==typeof t,function:t=>"function"==typeof t,boolean:t=>"boolean"==typeof t,string:t=>"string"==typeof t,stringOrUint8Array:t=>"string"==typeof t||Et(t),isSafeInteger:t=>Number.isSafeInteger(t),array:t=>Array.isArray(t),field:(t,n)=>n.Fp.isValid(t),hash:t=>"function"==typeof t&&Number.isSafeInteger(t.outputLen)};function Ht(t,n,e={}){const r=(s,o,c)=>{const f=sn[o];if("function"!=typeof f)throw new Error("invalid validator function");const i=t[s];if(!(c&&void 0===i||f(i,t)))throw new Error("param "+String(s)+" is invalid. Expected "+o+", got "+i)};for(const[s,o]of Object.entries(n))r(s,o,!1);for(const[s,o]of Object.entries(e))r(s,o,!0);return t}function Ae(t){const n=new WeakMap;return(e,...r)=>{const s=n.get(e);if(void 0!==s)return s;const o=t(e,...r);return n.set(e,o),o}}const K=BigInt(0),Z=BigInt(1),ht=BigInt(2),on=BigInt(3),Be=BigInt(4),ve=BigInt(5),_e=BigInt(8);function M(t,n){const e=t%n;return e>=K?e:n+e}function X(t,n,e){let r=t;for(;n-- >K;)r*=r,r%=e;return r}function Zt(t,n){if(t===K)throw new Error("invert: expected non-zero number");if(n<=K)throw new Error("invert: expected positive modulus, got "+n);let e=M(t,n),r=n,s=K,o=Z,c=Z,f=K;for(;e!==K;){const a=r/e,d=r%e,l=s-c*a,b=o-f*a;r=e,e=d,s=c,o=f,c=l,f=b}if(r!==Z)throw new Error("invert: does not exist");return M(s,n)}function He(t,n){const e=(t.ORDER+Z)/Be,r=t.pow(n,e);if(!t.eql(t.sqr(r),n))throw new Error("Cannot find square root");return r}function cn(t,n){const e=(t.ORDER-ve)/_e,r=t.mul(n,ht),s=t.pow(r,e),o=t.mul(n,s),c=t.mul(t.mul(o,ht),s),f=t.mul(o,t.sub(c,t.ONE));if(!t.eql(t.sqr(f),n))throw new Error("Cannot find square root");return f}function an(t){return t%Be===on?He:t%_e===ve?cn:function fn(t){if(t<BigInt(3))throw new Error("sqrt is not defined for small field");let n=t-Z,e=0;for(;n%ht===K;)n/=ht,e++;let r=ht;const s=Dt(t);for(;1===Xt(s,r);)if(r++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(1===e)return He;let o=s.pow(r,n);const c=(n+Z)/ht;return function(i,a){if(i.is0(a))return a;if(1!==Xt(i,a))throw new Error("Cannot find square root");let d=e,l=i.mul(i.ONE,o),b=i.pow(a,n),y=i.pow(a,c);for(;!i.eql(b,i.ONE);){if(i.is0(b))return i.ZERO;let E=1,h=i.sqr(b);for(;!i.eql(h,i.ONE);)if(E++,h=i.sqr(h),E===d)throw new Error("Cannot find square root");const q=Z<<BigInt(d-E-1),_=i.pow(l,q);d=E,l=i.sqr(_),b=i.mul(b,l),y=i.mul(y,_)}return y}}(t)}const ln=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function Ie(t){return Ht(t,ln.reduce((r,s)=>(r[s]="function",r),{ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"}))}function Oe(t,n,e){if(e<K)throw new Error("invalid exponent, negatives unsupported");if(e===K)return t.ONE;if(e===Z)return n;let r=t.ONE,s=n;for(;e>K;)e&Z&&(r=t.mul(r,s)),s=t.sqr(s),e>>=Z;return r}function Mt(t,n,e=!1){const r=new Array(n.length).fill(e?t.ZERO:void 0),s=n.reduce((c,f,i)=>t.is0(f)?c:(r[i]=c,t.mul(c,f)),t.ONE),o=t.inv(s);return n.reduceRight((c,f,i)=>t.is0(f)?c:(r[i]=t.mul(c,r[i]),t.mul(c,f)),o),r}function Xt(t,n){const e=(t.ORDER-Z)/ht,r=t.pow(n,e),s=t.eql(r,t.ONE),o=t.eql(r,t.ZERO),c=t.eql(r,t.neg(t.ONE));if(!s&&!o&&!c)throw new Error("invalid Legendre symbol result");return s?1:o?0:-1}function Qt(t,n){void 0!==n&&(0,T.k8)(n);const e=void 0!==n?n:t.toString(2).length;return{nBitLength:e,nByteLength:Math.ceil(e/8)}}function Dt(t,n,e=!1,r={}){if(t<=K)throw new Error("invalid field: expected ORDER > 0, got "+t);const{nBitLength:s,nByteLength:o}=Qt(t,n);if(o>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let c;const f=Object.freeze({ORDER:t,isLE:e,BITS:s,BYTES:o,MASK:kt(s),ZERO:K,ONE:Z,create:i=>M(i,t),isValid:i=>{if("bigint"!=typeof i)throw new Error("invalid field element: expected bigint, got "+typeof i);return K<=i&&i<t},is0:i=>i===K,isOdd:i=>(i&Z)===Z,neg:i=>M(-i,t),eql:(i,a)=>i===a,sqr:i=>M(i*i,t),add:(i,a)=>M(i+a,t),sub:(i,a)=>M(i-a,t),mul:(i,a)=>M(i*a,t),pow:(i,a)=>Oe(f,i,a),div:(i,a)=>M(i*Zt(a,t),t),sqrN:i=>i*i,addN:(i,a)=>i+a,subN:(i,a)=>i-a,mulN:(i,a)=>i*a,inv:i=>Zt(i,t),sqrt:r.sqrt||(i=>(c||(c=an(t)),c(f,i))),toBytes:i=>e?Ee(i,o):ut(i,o),fromBytes:i=>{if(i.length!==o)throw new Error("Field.fromBytes: expected "+o+" bytes, got "+i.length);return e?pe(i):J(i)},invertBatch:i=>Mt(f,i),cmov:(i,a,d)=>d?a:i});return Object.freeze(f)}function Ve(t){if("bigint"!=typeof t)throw new Error("field order must be bigint");const n=t.toString(2).length;return Math.ceil(n/8)}function qe(t){const n=Ve(t);return n+Math.ceil(n/2)}const Le=BigInt(0),$t=BigInt(1);function Jt(t,n){const e=n.negate();return t?e:n}function Ft(t,n){if(!Number.isSafeInteger(t)||t<=0||t>n)throw new Error("invalid window size, expected [1.."+n+"], got W="+t)}function te(t,n){Ft(t,n);const s=2**t;return{windows:Math.ceil(n/t)+1,windowSize:2**(t-1),mask:kt(t),maxNumber:s,shiftBy:BigInt(t)}}function Ne(t,n,e){const{windowSize:r,mask:s,maxNumber:o,shiftBy:c}=e;let f=Number(t&s),i=t>>c;f>r&&(f-=o,i+=$t);const a=n*r;return{nextN:i,offset:a+Math.abs(f)-1,isZero:0===f,isNeg:f<0,isNegF:n%2!=0,offsetF:a}}function Ue(t,n){if(!Array.isArray(t))throw new Error("array expected");t.forEach((e,r)=>{if(!(e instanceof n))throw new Error("invalid point at index "+r)})}function Ce(t,n){if(!Array.isArray(t))throw new Error("array of scalars expected");t.forEach((e,r)=>{if(!n.isValid(e))throw new Error("invalid scalar at index "+r)})}const ee=new WeakMap,Te=new WeakMap;function ne(t){return Te.get(t)||1}function hn(t,n,e,r){Ue(e,t),Ce(r,n);const s=e.length,o=r.length;if(s!==o)throw new Error("arrays of points and scalars must have equal length");const c=t.ZERO,f=function nn(t){let n;for(n=0;t>Rt;t>>=pt,n+=1);return n}(BigInt(s));let i=1;f>12?i=f-3:f>4?i=f-2:f>0&&(i=2);const a=kt(i),d=new Array(Number(a)+1).fill(c);let b=c;for(let y=Math.floor((n.BITS-1)/i)*i;y>=0;y-=i){d.fill(c);for(let h=0;h<o;h++){const q=r[h],_=Number(q>>BigInt(y)&a);d[_]=d[_].add(e[h])}let E=c;for(let h=d.length-1,q=c;h>0;h--)q=q.add(d[h]),E=E.add(q);if(b=b.add(E),0!==y)for(let h=0;h<i;h++)b=b.double()}return b}function Re(t){return Ie(t.Fp),Ht(t,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...Qt(t.n,t.nBitLength),...t,p:t.Fp.ORDER})}function ke(t){void 0!==t.lowS&&St("lowS",t.lowS),void 0!==t.prehash&&St("prehash",t.prehash)}class xn extends Error{constructor(n=""){super(n)}}const tt={Err:xn,_tlv:{encode:(t,n)=>{const{Err:e}=tt;if(t<0||t>256)throw new e("tlv.encode: wrong tag");if(1&n.length)throw new e("tlv.encode: unpadded data");const r=n.length/2,s=At(r);if(s.length/2&128)throw new e("tlv.encode: long form length too big");const o=r>127?At(s.length/2|128):"";return At(t)+o+s+n},decode(t,n){const{Err:e}=tt;let r=0;if(t<0||t>256)throw new e("tlv.encode: wrong tag");if(n.length<2||n[r++]!==t)throw new e("tlv.decode: wrong tlv");const s=n[r++];let c=0;if(!!(128&s)){const i=127&s;if(!i)throw new e("tlv.decode(long): indefinite length not supported");if(i>4)throw new e("tlv.decode(long): byte length is too big");const a=n.subarray(r,r+i);if(a.length!==i)throw new e("tlv.decode: length bytes not complete");if(0===a[0])throw new e("tlv.decode(long): zero leftmost byte");for(const d of a)c=c<<8|d;if(r+=i,c<128)throw new e("tlv.decode(long): not minimal encoding")}else c=s;const f=n.subarray(r,r+c);if(f.length!==c)throw new e("tlv.decode: wrong value length");return{v:f,l:n.subarray(r+c)}}},_int:{encode(t){const{Err:n}=tt;if(t<Q)throw new n("integer: negative integers are not allowed");let e=At(t);if(8&Number.parseInt(e[0],16)&&(e="00"+e),1&e.length)throw new n("unexpected DER parsing assertion: unpadded hex");return e},decode(t){const{Err:n}=tt;if(128&t[0])throw new n("invalid signature integer: negative");if(0===t[0]&&!(128&t[1]))throw new n("invalid signature integer: unnecessary leading zero");return J(t)}},toSig(t){const{Err:n,_int:e,_tlv:r}=tt,s=G("signature",t),{v:o,l:c}=r.decode(48,s);if(c.length)throw new n("invalid signature: left bytes after parsing");const{v:f,l:i}=r.decode(2,o),{v:a,l:d}=r.decode(2,i);if(d.length)throw new n("invalid signature: left bytes after parsing");return{r:e.decode(f),s:e.decode(a)}},hexFromSig(t){const{_tlv:n,_int:e}=tt,o=n.encode(2,e.encode(t.r))+n.encode(2,e.encode(t.s));return n.encode(48,o)}};function re(t,n){return Bt(ut(t,n))}const Q=BigInt(0),R=BigInt(1),ct=BigInt(2),It=BigInt(3),se=BigInt(4);function gn(t){const n=function bn(t){const n=Re(t);Ht(n,{a:"field",b:"field"},{allowInfinityPoint:"boolean",allowedPrivateKeyLengths:"array",clearCofactor:"function",fromBytes:"function",isTorsionFree:"function",toBytes:"function",wrapPrivateKey:"boolean"});const{endo:e,Fp:r,a:s}=n;if(e){if(!r.eql(s,r.ZERO))throw new Error("invalid endo: CURVE.a must be 0");if("object"!=typeof e||"bigint"!=typeof e.beta||"function"!=typeof e.splitScalar)throw new Error('invalid endo: expected "beta": bigint and "splitScalar": function')}return Object.freeze({...n})}(t),{Fp:e}=n,r=Dt(n.n,n.nBitLength),s=n.toBytes||((x,u,m)=>{const p=u.toAffine();return W(Uint8Array.from([4]),e.toBytes(p.x),e.toBytes(p.y))}),o=n.fromBytes||(x=>{const u=x.subarray(1);return{x:e.fromBytes(u.subarray(0,e.BYTES)),y:e.fromBytes(u.subarray(e.BYTES,2*e.BYTES))}});function c(x){const{a:u,b:m}=n,p=e.sqr(x),A=e.mul(p,x);return e.add(e.add(A,e.mul(x,u)),m)}function f(x,u){const m=e.sqr(u),p=c(x);return e.eql(m,p)}if(!f(n.Gx,n.Gy))throw new Error("bad curve params: generator point");const i=e.mul(e.pow(n.a,It),se),a=e.mul(e.sqr(n.b),BigInt(27));if(e.is0(e.add(i,a)))throw new Error("bad curve params: a or b");function l(x){const{allowedPrivateKeyLengths:u,nByteLength:m,wrapPrivateKey:p,n:A}=n;if(u&&"bigint"!=typeof x){if(Et(x)&&(x=Bt(x)),"string"!=typeof x||!u.includes(x.length))throw new Error("invalid private key");x=x.padStart(2*m,"0")}let B;try{B="bigint"==typeof x?x:J(G("private key",x,m))}catch{throw new Error("invalid private key, expected hex or "+m+" bytes, got "+typeof x)}return p&&(B=M(B,A)),dt("private key",B,R,A),B}function b(x){if(!(x instanceof h))throw new Error("ProjectivePoint expected")}const y=Ae((x,u)=>{const{px:m,py:p,pz:A}=x;if(e.eql(A,e.ONE))return{x:m,y:p};const B=x.is0();null==u&&(u=B?e.ONE:e.inv(A));const O=e.mul(m,u),C=e.mul(p,u),v=e.mul(A,u);if(B)return{x:e.ZERO,y:e.ZERO};if(!e.eql(v,e.ONE))throw new Error("invZ was invalid");return{x:O,y:C}}),E=Ae(x=>{if(x.is0()){if(n.allowInfinityPoint&&!e.is0(x.py))return;throw new Error("bad point: ZERO")}const{x:u,y:m}=x.toAffine();if(!e.isValid(u)||!e.isValid(m))throw new Error("bad point: x or y not FE");if(!f(u,m))throw new Error("bad point: equation left != right");if(!x.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});class h{constructor(u,m,p){if(null==u||!e.isValid(u))throw new Error("x required");if(null==m||!e.isValid(m)||e.is0(m))throw new Error("y required");if(null==p||!e.isValid(p))throw new Error("z required");this.px=u,this.py=m,this.pz=p,Object.freeze(this)}static fromAffine(u){const{x:m,y:p}=u||{};if(!u||!e.isValid(m)||!e.isValid(p))throw new Error("invalid affine point");if(u instanceof h)throw new Error("projective point not allowed");const A=B=>e.eql(B,e.ZERO);return A(m)&&A(p)?h.ZERO:new h(m,p,e.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(u){const m=Mt(e,u.map(p=>p.pz));return u.map((p,A)=>p.toAffine(m[A])).map(h.fromAffine)}static fromHex(u){const m=h.fromAffine(o(G("pointHex",u)));return m.assertValidity(),m}static fromPrivateKey(u){return h.BASE.multiply(l(u))}static msm(u,m){return hn(h,r,u,m)}_setWindowSize(u){U.setWindowSize(this,u)}assertValidity(){E(this)}hasEvenY(){const{y:u}=this.toAffine();if(e.isOdd)return!e.isOdd(u);throw new Error("Field doesn't support isOdd")}equals(u){b(u);const{px:m,py:p,pz:A}=this,{px:B,py:O,pz:C}=u,v=e.eql(e.mul(m,C),e.mul(B,A)),V=e.eql(e.mul(p,C),e.mul(O,A));return v&&V}negate(){return new h(this.px,e.neg(this.py),this.pz)}double(){const{a:u,b:m}=n,p=e.mul(m,It),{px:A,py:B,pz:O}=this;let C=e.ZERO,v=e.ZERO,V=e.ZERO,H=e.mul(A,A),D=e.mul(B,B),w=e.mul(O,O),g=e.mul(A,B);return g=e.add(g,g),V=e.mul(A,O),V=e.add(V,V),C=e.mul(u,V),v=e.mul(p,w),v=e.add(C,v),C=e.sub(D,v),v=e.add(D,v),v=e.mul(C,v),C=e.mul(g,C),V=e.mul(p,V),w=e.mul(u,w),g=e.sub(H,w),g=e.mul(u,g),g=e.add(g,V),V=e.add(H,H),H=e.add(V,H),H=e.add(H,w),H=e.mul(H,g),v=e.add(v,H),w=e.mul(B,O),w=e.add(w,w),H=e.mul(w,g),C=e.sub(C,H),V=e.mul(w,D),V=e.add(V,V),V=e.add(V,V),new h(C,v,V)}add(u){b(u);const{px:m,py:p,pz:A}=this,{px:B,py:O,pz:C}=u;let v=e.ZERO,V=e.ZERO,H=e.ZERO;const D=n.a,w=e.mul(n.b,It);let g=e.mul(m,B),S=e.mul(p,O),N=e.mul(A,C),I=e.add(m,p),L=e.add(B,O);I=e.mul(I,L),L=e.add(g,S),I=e.sub(I,L),L=e.add(m,A);let k=e.add(B,C);return L=e.mul(L,k),k=e.add(g,N),L=e.sub(L,k),k=e.add(p,A),v=e.add(O,C),k=e.mul(k,v),v=e.add(S,N),k=e.sub(k,v),H=e.mul(D,L),v=e.mul(w,N),H=e.add(v,H),v=e.sub(S,H),H=e.add(S,H),V=e.mul(v,H),S=e.add(g,g),S=e.add(S,g),N=e.mul(D,N),L=e.mul(w,L),S=e.add(S,N),N=e.sub(g,N),N=e.mul(D,N),L=e.add(L,N),g=e.mul(S,L),V=e.add(V,g),g=e.mul(k,L),v=e.mul(I,v),v=e.sub(v,g),g=e.mul(I,S),H=e.mul(k,H),H=e.add(H,g),new h(v,V,H)}subtract(u){return this.add(u.negate())}is0(){return this.equals(h.ZERO)}wNAF(u){return U.wNAFCached(this,u,h.normalizeZ)}multiplyUnsafe(u){const{endo:m,n:p}=n;dt("scalar",u,Q,p);const A=h.ZERO;if(u===Q)return A;if(this.is0()||u===R)return this;if(!m||U.hasPrecomputes(this))return U.wNAFCachedUnsafe(this,u,h.normalizeZ);let{k1neg:B,k1:O,k2neg:C,k2:v}=m.splitScalar(u),V=A,H=A,D=this;for(;O>Q||v>Q;)O&R&&(V=V.add(D)),v&R&&(H=H.add(D)),D=D.double(),O>>=R,v>>=R;return B&&(V=V.negate()),C&&(H=H.negate()),H=new h(e.mul(H.px,m.beta),H.py,H.pz),V.add(H)}multiply(u){const{endo:m,n:p}=n;let A,B;if(dt("scalar",u,R,p),m){const{k1neg:O,k1:C,k2neg:v,k2:V}=m.splitScalar(u);let{p:H,f:D}=this.wNAF(C),{p:w,f:g}=this.wNAF(V);H=U.constTimeNegate(O,H),w=U.constTimeNegate(v,w),w=new h(e.mul(w.px,m.beta),w.py,w.pz),A=H.add(w),B=D.add(g)}else{const{p:O,f:C}=this.wNAF(u);A=O,B=C}return h.normalizeZ([A,B])[0]}multiplyAndAddUnsafe(u,m,p){const A=h.BASE,B=(C,v)=>v!==Q&&v!==R&&C.equals(A)?C.multiply(v):C.multiplyUnsafe(v),O=B(this,m).add(B(u,p));return O.is0()?void 0:O}toAffine(u){return y(this,u)}isTorsionFree(){const{h:u,isTorsionFree:m}=n;if(u===R)return!0;if(m)return m(h,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:u,clearCofactor:m}=n;return u===R?this:m?m(h,this):this.multiplyUnsafe(n.h)}toRawBytes(u=!0){return St("isCompressed",u),this.assertValidity(),s(h,this,u)}toHex(u=!0){return St("isCompressed",u),Bt(this.toRawBytes(u))}}h.BASE=new h(n.Gx,n.Gy,e.ONE),h.ZERO=new h(e.ZERO,e.ONE,e.ZERO);const{endo:q,nBitLength:_}=n,U=function dn(t,n){return{constTimeNegate:Jt,hasPrecomputes:e=>1!==ne(e),unsafeLadder(e,r,s=t.ZERO){let o=e;for(;r>Le;)r&$t&&(s=s.add(o)),o=o.double(),r>>=$t;return s},precomputeWindow(e,r){const{windows:s,windowSize:o}=te(r,n),c=[];let f=e,i=f;for(let a=0;a<s;a++){i=f,c.push(i);for(let d=1;d<o;d++)i=i.add(f),c.push(i);f=i.double()}return c},wNAF(e,r,s){let o=t.ZERO,c=t.BASE;const f=te(e,n);for(let i=0;i<f.windows;i++){const{nextN:a,offset:d,isZero:l,isNeg:b,isNegF:y,offsetF:E}=Ne(s,i,f);s=a,l?c=c.add(Jt(y,r[E])):o=o.add(Jt(b,r[d]))}return{p:o,f:c}},wNAFUnsafe(e,r,s,o=t.ZERO){const c=te(e,n);for(let f=0;f<c.windows&&s!==Le;f++){const{nextN:i,offset:a,isZero:d,isNeg:l}=Ne(s,f,c);if(s=i,!d){const b=r[a];o=o.add(l?b.negate():b)}}return o},getPrecomputes(e,r,s){let o=ee.get(r);return o||(o=this.precomputeWindow(r,e),1!==e&&ee.set(r,s(o))),o},wNAFCached(e,r,s){const o=ne(e);return this.wNAF(o,this.getPrecomputes(o,e,s),r)},wNAFCachedUnsafe(e,r,s,o){const c=ne(e);return 1===c?this.unsafeLadder(e,r,o):this.wNAFUnsafe(c,this.getPrecomputes(c,e,s),r,o)},setWindowSize(e,r){Ft(r,n),Te.set(e,r),ee.delete(e)}}}(h,q?Math.ceil(_/2):_);return{CURVE:n,ProjectivePoint:h,normPrivateKeyToScalar:l,weierstrassEquation:c,isWithinCurveOrder:function d(x){return _t(x,R,n.n)}}}function mn(t){const n=function wn(t){const n=Re(t);return Ht(n,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...n})}(t),{Fp:e,n:r,nByteLength:s,nBitLength:o}=n,c=e.BYTES+1,f=2*e.BYTES+1;function i(w){return M(w,r)}function a(w){return Zt(w,r)}const{ProjectivePoint:d,normPrivateKeyToScalar:l,weierstrassEquation:b,isWithinCurveOrder:y}=gn({...n,toBytes(w,g,S){const N=g.toAffine(),I=e.toBytes(N.x),L=W;return St("isCompressed",S),S?L(Uint8Array.from([g.hasEvenY()?2:3]),I):L(Uint8Array.from([4]),I,e.toBytes(N.y))},fromBytes(w){const g=w.length,S=w[0],N=w.subarray(1);if(g!==c||2!==S&&3!==S){if(g===f&&4===S){return{x:e.fromBytes(N.subarray(0,e.BYTES)),y:e.fromBytes(N.subarray(e.BYTES,2*e.BYTES))}}throw new Error("invalid Point, expected length of "+c+", or uncompressed "+f+", got "+g)}{const I=J(N);if(!_t(I,R,e.ORDER))throw new Error("Point is not on curve");const L=b(I);let k;try{k=e.sqrt(L)}catch($){const Y=$ instanceof Error?": "+$.message:"";throw new Error("Point is not on curve"+Y)}return 1==(1&S)!==((k&R)===R)&&(k=e.neg(k)),{x:I,y:k}}}});function E(w){return w>r>>R}const q=(w,g,S)=>J(w.slice(g,S));class _{constructor(g,S,N){dt("r",g,R,r),dt("s",S,R,r),this.r=g,this.s=S,null!=N&&(this.recovery=N),Object.freeze(this)}static fromCompact(g){const S=s;return g=G("compactSignature",g,2*S),new _(q(g,0,S),q(g,S,2*S))}static fromDER(g){const{r:S,s:N}=tt.toSig(G("DER",g));return new _(S,N)}assertValidity(){}addRecoveryBit(g){return new _(this.r,this.s,g)}recoverPublicKey(g){const{r:S,s:N,recovery:I}=this,L=A(G("msgHash",g));if(null==I||![0,1,2,3].includes(I))throw new Error("recovery id invalid");const k=2===I||3===I?S+n.n:S;if(k>=e.ORDER)throw new Error("recovery id 2 or 3 invalid");const j=1&I?"03":"02",et=d.fromHex(j+re(k,e.BYTES)),$=a(k),Y=i(-L*$),wt=i(N*$),lt=d.BASE.multiplyAndAddUnsafe(et,Y,wt);if(!lt)throw new Error("point at infinify");return lt.assertValidity(),lt}hasHighS(){return E(this.s)}normalizeS(){return this.hasHighS()?new _(this.r,i(-this.s),this.recovery):this}toDERRawBytes(){return vt(this.toDERHex())}toDERHex(){return tt.hexFromSig(this)}toCompactRawBytes(){return vt(this.toCompactHex())}toCompactHex(){const g=s;return re(this.r,g)+re(this.s,g)}}const U={isValidPrivateKey(w){try{return l(w),!0}catch{return!1}},normPrivateKeyToScalar:l,randomPrivateKey:()=>{const w=qe(n.n);return function un(t,n,e=!1){const r=t.length,s=Ve(n),o=qe(n);if(r<16||r<o||r>1024)throw new Error("expected "+o+"-1024 bytes of input, got "+r);const f=M(e?pe(t):J(t),n-Z)+Z;return e?Ee(f,s):ut(f,s)}(n.randomBytes(w),n.n)},precompute:(w=8,g=d.BASE)=>(g._setWindowSize(w),g.multiply(BigInt(3)),g)};function u(w){if("bigint"==typeof w)return!1;if(w instanceof d)return!0;const S=G("key",w).length,N=e.BYTES,I=N+1,L=2*N+1;return n.allowedPrivateKeyLengths||s===I?void 0:S===I||S===L}const p=n.bits2int||function(w){if(w.length>8192)throw new Error("input is too large");const g=J(w),S=8*w.length-o;return S>0?g>>BigInt(S):g},A=n.bits2int_modN||function(w){return i(p(w))},B=kt(o);function O(w){return dt("num < 2^"+o,w,Q,B),ut(w,s)}function C(w,g,S=v){if(["recovered","canonical"].some(bt=>bt in S))throw new Error("sign() legacy options not supported");const{hash:N,randomBytes:I}=n;let{lowS:L,prehash:k,extraEntropy:j}=S;null==L&&(L=!0),w=G("msgHash",w),ke(S),k&&(w=G("prehashed msgHash",N(w)));const et=A(w),$=l(g),Y=[O($),O(et)];if(null!=j&&!1!==j){const bt=!0===j?I(e.BYTES):j;Y.push(G("extraEntropy",bt))}const wt=W(...Y),lt=et;return{seed:wt,k2sig:function de(bt){const mt=p(bt);if(!y(mt))return;const he=a(mt),Ut=d.BASE.multiply(mt).toAffine(),xt=i(Ut.x);if(xt===Q)return;const Ct=i(he*i(lt+xt*$));if(Ct===Q)return;let yt=(Ut.x===xt?0:2)|Number(Ut.y&R),je=Ct;return L&&E(Ct)&&(je=function h(w){return E(w)?i(-w):w}(Ct),yt^=1),new _(xt,je,yt)}}}const v={lowS:n.lowS,prehash:!1},V={lowS:n.lowS,prehash:!1};return d.BASE._setWindowSize(8),{CURVE:n,getPublicKey:function x(w,g=!0){return d.fromPrivateKey(w).toRawBytes(g)},getSharedSecret:function m(w,g,S=!0){if(!0===u(w))throw new Error("first arg must be private key");if(!1===u(g))throw new Error("second arg must be public key");return d.fromHex(g).multiply(l(w)).toRawBytes(S)},sign:function H(w,g,S=v){const{seed:N,k2sig:I}=C(w,g,S),L=n;return function rn(t,n,e){if("number"!=typeof t||t<2)throw new Error("hashLen must be a number");if("number"!=typeof n||n<2)throw new Error("qByteLen must be a number");if("function"!=typeof e)throw new Error("hmacFn must be a function");let r=Wt(t),s=Wt(t),o=0;const c=()=>{r.fill(1),s.fill(0),o=0},f=(...l)=>e(s,r,...l),i=(l=Wt(0))=>{s=f(Se([0]),l),r=f(),0!==l.length&&(s=f(Se([1]),l),r=f())},a=()=>{if(o++>=1e3)throw new Error("drbg: tried 1000 values");let l=0;const b=[];for(;l<n;){r=f();const y=r.slice();b.push(y),l+=r.length}return W(...b)};return(l,b)=>{let y;for(c(),i(l);!(y=b(a()));)i();return c(),y}}(L.hash.outputLen,L.nByteLength,L.hmac)(N,I)},verify:function D(w,g,S,N=V){const I=w;g=G("msgHash",g),S=G("publicKey",S);const{lowS:L,prehash:k,format:j}=N;if(ke(N),"strict"in N)throw new Error("options.strict was renamed to lowS");if(void 0!==j&&"compact"!==j&&"der"!==j)throw new Error("format must be compact or der");const et="string"==typeof I||Et(I),$=!et&&!j&&"object"==typeof I&&null!==I&&"bigint"==typeof I.r&&"bigint"==typeof I.s;if(!et&&!$)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let Y,wt;try{if($&&(Y=new _(I.r,I.s)),et){try{"compact"!==j&&(Y=_.fromDER(I))}catch(yt){if(!(yt instanceof tt.Err))throw yt}!Y&&"der"!==j&&(Y=_.fromCompact(I))}wt=d.fromHex(S)}catch{return!1}if(!Y||L&&Y.hasHighS())return!1;k&&(g=n.hash(g));const{r:lt,s:de}=Y,bt=A(g),mt=a(de),he=i(bt*mt),Ut=i(lt*mt),xt=d.BASE.multiplyAndAddUnsafe(wt,he,Ut)?.toAffine();return!!xt&&i(xt.x)===lt},ProjectivePoint:d,Signature:_,utils:U}}function pn(t,n){if(Ie(t),!t.isValid(n.A)||!t.isValid(n.B)||!t.isValid(n.Z))throw new Error("mapToCurveSimpleSWU: invalid opts");const e=function yn(t,n){const e=t.ORDER;let r=Q;for(let E=e-R;E%ct===Q;E/=ct)r+=R;const s=r,o=ct<<s-R-R,c=o*ct,f=(e-R)/c,i=(f-R)/ct,a=c-R,d=o,l=t.pow(n,f),b=t.pow(n,(f+R)/ct);let y=(E,h)=>{let q=l,_=t.pow(h,a),U=t.sqr(_);U=t.mul(U,h);let x=t.mul(E,U);x=t.pow(x,i),x=t.mul(x,_),_=t.mul(x,h),U=t.mul(x,E);let u=t.mul(U,_);x=t.pow(u,d);let m=t.eql(x,t.ONE);_=t.mul(U,b),x=t.mul(u,q),U=t.cmov(_,U,m),u=t.cmov(x,u,m);for(let p=s;p>R;p--){let A=p-ct;A=ct<<A-R;let B=t.pow(u,A);const O=t.eql(B,t.ONE);_=t.mul(U,q),q=t.mul(q,q),B=t.mul(u,q),U=t.cmov(_,U,O),u=t.cmov(B,u,O)}return{isValid:m,value:U}};if(t.ORDER%se===It){const E=(t.ORDER-It)/se,h=t.sqrt(t.neg(n));y=(q,_)=>{let U=t.sqr(_);const x=t.mul(q,_);U=t.mul(U,x);let u=t.pow(U,E);u=t.mul(u,x);const m=t.mul(u,h),p=t.mul(t.sqr(u),_),A=t.eql(p,q);return{isValid:A,value:t.cmov(m,u,A)}}}return y}(t,n.Z);if(!t.isOdd)throw new Error("Fp.isOdd is not implemented!");return r=>{let s,o,c,f,i,a,d,l;s=t.sqr(r),s=t.mul(s,n.Z),o=t.sqr(s),o=t.add(o,s),c=t.add(o,t.ONE),c=t.mul(c,n.B),f=t.cmov(n.Z,t.neg(o),!t.eql(o,t.ZERO)),f=t.mul(f,n.A),o=t.sqr(c),a=t.sqr(f),i=t.mul(a,n.A),o=t.add(o,i),o=t.mul(o,c),a=t.mul(a,f),i=t.mul(a,n.B),o=t.add(o,i),d=t.mul(s,c);const{isValid:b,value:y}=e(o,a);l=t.mul(s,r),l=t.mul(l,y),d=t.cmov(d,c,b),l=t.cmov(l,y,b);const E=t.isOdd(r)===t.isOdd(l);l=t.cmov(t.neg(l),l,E);const h=Mt(t,[f],!0)[0];return d=t.mul(d,h),{x:d,y:l}}}function En(t){return{hash:t,hmac:(n,...e)=>ge(t,n,(0,T.eV)(...e)),randomBytes:T.O6}}const An=J;function ft(t,n){if(Ot(t),Ot(n),t<0||t>=1<<8*n)throw new Error("invalid I2OSP input: "+t);const e=Array.from({length:n}).fill(0);for(let r=n-1;r>=0;r--)e[r]=255&t,t>>>=8;return new Uint8Array(e)}function Bn(t,n){const e=new Uint8Array(t.length);for(let r=0;r<t.length;r++)e[r]=t[r]^n[r];return e}function Ot(t){if(!Number.isSafeInteger(t))throw new Error("number expected")}function Ze(t,n,e){Ht(e,{DST:"stringOrUint8Array",p:"bigint",m:"isSafeInteger",k:"isSafeInteger",hash:"hash"});const{p:r,k:s,m:o,hash:c,expand:f,DST:i}=e;it(t),Ot(n);const a="string"==typeof i?jt(i):i,d=r.toString(2).length,l=Math.ceil((d+s)/8),b=n*o*l;let y;if("xmd"===f)y=function vn(t,n,e,r){it(t),it(n),Ot(e),n.length>255&&(n=r(W(jt("H2C-OVERSIZE-DST-"),n)));const{outputLen:s,blockLen:o}=r,c=Math.ceil(e/s);if(e>65535||c>255)throw new Error("expand_message_xmd: invalid lenInBytes");const f=W(n,ft(n.length,1)),i=ft(0,o),a=ft(e,2),d=new Array(c),l=r(W(i,t,a,ft(0,1),f));d[0]=r(W(l,ft(1,1),f));for(let y=1;y<=c;y++){const E=[Bn(l,d[y-1]),ft(y+1,1),f];d[y]=r(W(...E))}return W(...d).slice(0,e)}(t,a,b,c);else if("xof"===f)y=function _n(t,n,e,r,s){if(it(t),it(n),Ot(e),n.length>255){const o=Math.ceil(2*r/8);n=s.create({dkLen:o}).update(jt("H2C-OVERSIZE-DST-")).update(n).digest()}if(e>65535||n.length>255)throw new Error("expand_message_xof: invalid lenInBytes");return s.create({dkLen:e}).update(t).update(ft(e,2)).update(n).update(ft(n.length,1)).digest()}(t,a,b,s,c);else{if("_internal_pass"!==f)throw new Error('expand must be "xmd" or "xof"');y=t}const E=new Array(n);for(let h=0;h<n;h++){const q=new Array(o);for(let _=0;_<o;_++){const U=l*(_+h*o),x=y.subarray(U,U+l);q[_]=M(An(x),r)}E[h]=q}return E}const Vt=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),Gt=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),oe=BigInt(0),qt=BigInt(1),zt=BigInt(2),Me=(t,n)=>(t+n/zt)/n;function De(t){const n=Vt,e=BigInt(3),r=BigInt(6),s=BigInt(11),o=BigInt(22),c=BigInt(23),f=BigInt(44),i=BigInt(88),a=t*t*t%n,d=a*a*t%n,l=X(d,e,n)*d%n,b=X(l,e,n)*d%n,y=X(b,zt,n)*a%n,E=X(y,s,n)*y%n,h=X(E,o,n)*E%n,q=X(h,f,n)*h%n,_=X(q,i,n)*q%n,U=X(_,f,n)*h%n,x=X(U,e,n)*d%n,u=X(x,c,n)*E%n,m=X(u,r,n)*a%n,p=X(m,zt,n);if(!at.eql(at.sqr(p),t))throw new Error("Cannot find square root");return p}const at=Dt(Vt,void 0,void 0,{sqrt:De}),Lt=function Sn(t,n){const e=r=>mn({...t,...En(r)});return{...e(n),create:e}}({a:oe,b:BigInt(7),Fp:at,n:Gt,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:t=>{const n=Gt,e=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),r=-qt*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),s=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),o=e,c=BigInt("0x100000000000000000000000000000000"),f=Me(o*t,n),i=Me(-r*t,n);let a=M(t-f*e-i*s,n),d=M(-f*r-i*o,n);const l=a>c,b=d>c;if(l&&(a=n-a),b&&(d=n-d),a>c||d>c)throw new Error("splitScalar: Endomorphism failed, k="+t);return{k1neg:l,k1:a,k2neg:b,k2:d}}}},Tt),Ge={};function Pt(t,...n){let e=Ge[t];if(void 0===e){const r=Tt(Uint8Array.from(t,s=>s.charCodeAt(0)));e=W(r,r),Ge[t]=e}return Tt(W(e,...n))}const ie=t=>t.toRawBytes(!0).slice(1),ce=t=>ut(t,32),fe=t=>M(t,Vt),Nt=t=>M(t,Gt),ae=(()=>Lt.ProjectivePoint)(),On=(t,n,e)=>ae.BASE.multiplyAndAddUnsafe(t,n,e);function le(t){let n=Lt.utils.normPrivateKeyToScalar(t),e=ae.fromPrivateKey(n);return{scalar:e.hasEvenY()?n:Nt(-n),bytes:ie(e)}}function ze(t){dt("x",t,qt,Vt);const n=fe(t*t);let r=De(fe(n*t+BigInt(7)));r%zt!==oe&&(r=fe(-r));const s=new ae(t,r,qt);return s.assertValidity(),s}const gt=J;function Pe(...t){return Nt(gt(Pt("BIP0340/challenge",...t)))}function Vn(t){return le(t).bytes}function qn(t,n,e=(0,T.O6)(32)){const r=G("message",t),{bytes:s,scalar:o}=le(n),c=G("auxRand",e,32),f=ce(o^gt(Pt("BIP0340/aux",c))),i=Pt("BIP0340/nonce",f,s,r),a=Nt(gt(i));if(a===oe)throw new Error("sign failed: k is zero");const{bytes:d,scalar:l}=le(a),b=Pe(d,s,r),y=new Uint8Array(64);if(y.set(d,0),y.set(ce(Nt(l+b*o)),32),!Ke(y,r,s))throw new Error("sign: Invalid signature produced");return y}function Ke(t,n,e){const r=G("signature",t,64),s=G("message",n),o=G("publicKey",e,32);try{const c=ze(gt(o)),f=gt(r.subarray(0,32));if(!_t(f,qt,Vt))return!1;const i=gt(r.subarray(32,64));if(!_t(i,qt,Gt))return!1;const a=Pe(ce(f),ie(c),s),d=On(c,i,Nt(-a));return!(!d||!d.hasEvenY()||d.toAffine().x!==f)}catch{return!1}}const Ln=(()=>({getPublicKey:Vn,sign:qn,verify:Ke,utils:{randomPrivateKey:Lt.utils.randomPrivateKey,lift_x:ze,pointToBytes:ie,numberToBytesBE:ut,bytesToNumberBE:J,taggedHash:Pt,mod:M}}))(),Nn=(()=>function Hn(t,n){const e=n.map(r=>Array.from(r).reverse());return(r,s)=>{const[o,c,f,i]=e.map(l=>l.reduce((b,y)=>t.add(t.mul(b,r),y))),[a,d]=Mt(t,[c,i],!0);return r=t.mul(o,a),s=t.mul(s,t.mul(f,d)),{x:r,y:s}}}(at,[["0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7","0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581","0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262","0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"],["0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b","0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14","0x0000000000000000000000000000000000000000000000000000000000000001"],["0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c","0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3","0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931","0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"],["0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b","0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573","0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f","0x0000000000000000000000000000000000000000000000000000000000000001"]].map(t=>t.map(n=>BigInt(n)))))(),Un=(()=>pn(at,{A:BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),B:BigInt("1771"),Z:at.create(BigInt("-11"))}))(),ue=(()=>function In(t,n,e){if("function"!=typeof n)throw new Error("mapToCurve() must be defined");function r(o){return t.fromAffine(n(o))}function s(o){const c=o.clearCofactor();return c.equals(t.ZERO)?t.ZERO:(c.assertValidity(),c)}return{defaults:e,hashToCurve(o,c){const f=Ze(o,2,{...e,DST:e.DST,...c}),i=r(f[0]),a=r(f[1]);return s(i.add(a))},encodeToCurve:(o,c)=>s(r(Ze(o,1,{...e,DST:e.encodeDST,...c})[0])),mapToCurve(o){if(!Array.isArray(o))throw new Error("expected array of bigints");for(const c of o)if("bigint"!=typeof c)throw new Error("expected array of bigints");return s(r(o))}}}(Lt.ProjectivePoint,t=>{const{x:n,y:e}=Un(at.create(t[0]));return Nn(n,e)},{DST:"secp256k1_XMD:SHA-256_SSWU_RO_",encodeDST:"secp256k1_XMD:SHA-256_SSWU_NU_",p:at.ORDER,m:1,k:128,expand:"xmd",hash:Tt}))(),Cn=(()=>ue.hashToCurve)(),Tn=(()=>ue.encodeToCurve)()}}]);